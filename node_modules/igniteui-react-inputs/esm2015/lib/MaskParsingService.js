/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, String_$type, fromEnum, Number_$type, markType } from "igniteui-react-core";
import { Dictionary$2 } from "igniteui-react-core";
import { ObservableCollection$1 } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { Replaced } from "./Replaced";
/**
 * @hidden
 */
export let MaskParsingService = /*@__PURE__*/ (() => {
    class MaskParsingService extends Base {
        g(a, b) {
            let c = "";
            let d = "";
            let e = b.a;
            let f = this.c(e);
            let g = f.keys;
            let h = this.e(e, g);
            let i = f.values;
            if (a != null) {
                d = a.toString();
            }
            for (let j = 0; j < e.length; j++) {
                c += b.b;
            }
            for (let k of fromEnum(f)) {
                c = this.i(c, k.key, k.value);
            }
            if (d == "") {
                return c;
            }
            let l = this.f(d, i);
            for (let m = 0; m < l.count; m++) {
                let n = l._inner[m];
                let o = this.b(n, h._inner[m], e);
                if (!o && n != b.b) {
                    l.item(m, b.b);
                }
            }
            if (l.count > h.count) {
                l.v(h.count + 1, l.count);
            }
            let p = 0;
            for (let q of fromEnum(l)) {
                let r = q;
                c = this.i(c, h._inner[p++], r);
            }
            return c;
        }
        h(a, b) {
            let c = "";
            let d = b.a;
            let e = this.c(d);
            let f = e.values;
            for (let g = 0; g < a.length; g++) {
                let h = a.charAt(g).toString();
                if (!f.contains(h)) {
                    if (h != b.b) {
                        c += h;
                    }
                }
            }
            return c;
        }
        a(a, b, c, d, e) {
            let f = this.c(c.a).keys;
            let g = new ObservableCollection$1(String_$type, 0);
            for (let h = 0; h < b.length; h++) {
                g.add(b.charAt(h).toString());
            }
            let i = d;
            e = Math.min(e, a.length);
            for (let j = d; j < e || (g.count > 0 && j < a.length); j++) {
                if (f.contains(j)) {
                    if (g._inner[0] == a.charAt(j).toString()) {
                        i = j + 1;
                        g.removeAt(0);
                    }
                    continue;
                }
                if (g._inner[0] != null && !this.b(g._inner[0].toString(), j, c.a) && g._inner[0].toString() != c.b) {
                    break;
                }
                let k = c.b;
                if (g.count > 0) {
                    i = j + 1;
                    k = g._inner[0];
                    g.removeAt(0);
                }
                a = this.i(a, j, k);
            }
            let l = new Replaced();
            l.b = a;
            l.a = i;
            return l;
        }
        i(a, b, c) {
            if (a != null) {
                return a.substr(0, b) + c + a.substr(b + 1);
            }
            return null;
        }
        b(a, b, c) {
            let d;
            let e;
            let f = "[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]";
            let g = "[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]";
            let h = "[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]";
            let i = "[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]";
            let j = "[\\d]";
            let k = "[\\d\\u0020]";
            let l = "[\\d-\\+\\s]";
            switch (c.charAt(b)) {
                case 'C':
                    e = a != "";
                    break;
                case '&':
                    d = new RegExp("[\\u0020]");
                    e = !d.test(a);
                    break;
                case 'a':
                    d = new RegExp(g);
                    e = d.test(a);
                    break;
                case 'A':
                    d = new RegExp(f);
                    e = d.test(a);
                    break;
                case '?':
                    d = new RegExp(i);
                    e = d.test(a);
                    break;
                case 'L':
                    d = new RegExp(h);
                    e = d.test(a);
                    break;
                case '0':
                    d = new RegExp(j);
                    e = d.test(a);
                    break;
                case '9':
                    d = new RegExp(k);
                    e = d.test(a);
                    break;
                case '#':
                    d = new RegExp(l);
                    e = d.test(a);
                    break;
                default:
                    e = false;
                    break;
            }
            return e;
        }
        c(a) {
            let b = new Dictionary$2(Number_$type, String_$type, 0);
            for (let c = 0; c < a.length; c++) {
                let d = a.charAt(c);
                if (!MaskParsingService.d.contains(d)) {
                    b.addItem(c, d.toString());
                }
            }
            return b;
        }
        e(a, b) {
            let c = new ObservableCollection$1(Number_$type, 0);
            for (let d = 0; d < a.length; d++) {
                if (!b.contains(d)) {
                    c.add(d);
                }
            }
            return c;
        }
        f(a, b) {
            let c = new ObservableCollection$1(String_$type, 0);
            for (let d = 0; d < a.length; d++) {
                let e = a.charAt(d).toString();
                if (!b.contains(e)) {
                    b.remove(e);
                    c.add(e);
                }
            }
            return c;
        }
    }
    MaskParsingService.$t = /*@__PURE__*/ markType(MaskParsingService, 'MaskParsingService');
    MaskParsingService.d = /*@__PURE__*/ ((() => {
        let $ret = new List$1(String_$type, 0);
        $ret.add('C');
        $ret.add('&');
        $ret.add('a');
        $ret.add('A');
        $ret.add('?');
        $ret.add('L');
        $ret.add('9');
        $ret.add('0');
        $ret.add('#');
        return $ret;
    })());
    return MaskParsingService;
})();
//# sourceMappingURL=MaskParsingService.js.map
