import * as React from 'react';
import { IgrSectionHeader } from './igr-section-header';
import { IgrSummaryRowRoot } from './igr-summary-row-root';
import { IgrSummaryRowSection } from './igr-summary-row-section';
import { IgrColumnWidth } from './igr-column-width';
import { ColumnWidth as ColumnWidth_internal } from './ColumnWidth';
import { HeaderClickAction_$type } from './HeaderClickAction';
import { ColumnShowingAnimationMode_$type } from './ColumnShowingAnimationMode';
import { ColumnPropertyUpdatingAnimationMode, ColumnPropertyUpdatingAnimationMode_$type } from './ColumnPropertyUpdatingAnimationMode';
import { CellDataLoadedAnimationMode_$type } from './CellDataLoadedAnimationMode';
import { RowSelectionAnimationMode_$type } from './RowSelectionAnimationMode';
import { ColumnMovingAnimationMode_$type } from './ColumnMovingAnimationMode';
import { ColumnHidingAnimationMode_$type } from './ColumnHidingAnimationMode';
import { CellSelectionAnimationMode_$type } from './CellSelectionAnimationMode';
import { ColumnExchangingAnimationMode_$type } from './ColumnExchangingAnimationMode';
import { RowHoverAnimationMode_$type } from './RowHoverAnimationMode';
import { GridSelectionMode_$type } from './GridSelectionMode';
import { GridActivationMode_$type } from './GridActivationMode';
import { GridSelectionBehavior_$type } from './GridSelectionBehavior';
import { IgrGridCellEventArgs } from './igr-grid-cell-event-args';
import { IgrGridColumnsAutoGeneratedEventArgs } from './igr-grid-columns-auto-generated-event-args';
import { IgrGridColumnsChangedEventArgs } from './igr-grid-columns-changed-event-args';
import { IgrGridSelectedItemsChangedEventArgs } from './igr-grid-selected-items-changed-event-args';
import { IgrGridSelectedKeysChangedEventArgs } from './igr-grid-selected-keys-changed-event-args';
import { IgrGridSelectedCellsChangedEventArgs } from './igr-grid-selected-cells-changed-event-args';
import { IgrGridSelectedCellRangesChangedEventArgs } from './igr-grid-selected-cell-ranges-changed-event-args';
import { IgrGridSortDescriptionsChangedEventArgs } from './igr-grid-sort-descriptions-changed-event-args';
import { IgrGridGroupDescriptionsChangedEventArgs } from './igr-grid-group-descriptions-changed-event-args';
import { Grid } from "./Grid";
import { ensureEnum, ensureBool, CollectionAdapter, toSpinal, brushToString, stringToBrush, initializePropertiesFromCss, NamePatcher, isValidProp, getModifiedProps } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { ReactRenderer, ReactWrapper, PortalManager } from "igniteui-react-core";
import { Column } from './Column';
import { DataGridCellLayoutPanel } from './DataGridCellLayoutPanel';
import { Base } from "igniteui-react-core";
import { GridExternalWrapper } from './GridExternalWrapper';
import { BrowserTickProvider } from './BrowserTickProvider';
import { BrowserPixelConverter } from './BrowserPixelConverter';
import { DataGridPresenterManager } from './DataGridPresenterManager';
import { DataGridViewportManager } from './DataGridViewportManager';
import { DataGridDelayedExecutionManager } from './DataGridDelayedExecutionManager';
import { DataGridPropertySetter } from './DataGridPropertySetter';
import { IgrGridColumnCollection } from './igr-grid-column-collection';
import { SyncableObservableCollection$1 } from "igniteui-react-core";
import { NotifyCollectionChangedAction } from "igniteui-react-core";
import { Scroller } from "igniteui-react-core";
import { ScrollbarStyle_$type } from "igniteui-react-core";
import { Dragger } from "./Dragger";
import { DataGridStylingDefaults } from './DataGridStylingDefaults';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { FontInfo } from "igniteui-react-core";
import { IgrColumnSortDescriptionCollection } from './igr-column-sort-description-collection';
import { IgrColumnGroupDescriptionCollection } from './igr-column-group-description-collection';
import { IgrColumnSummaryDescriptionCollection } from './igr-column-summary-description-collection';
import { IgrFilterExpressionCollection } from "igniteui-react-core";
import { IgrGridSelectedItemsCollection } from "./igr-grid-selected-items-collection";
import { IgrGridSelectedKeysCollection } from "./igr-grid-selected-keys-collection";
import { IgrGridSelectedCellsCollection } from "./igr-grid-selected-cells-collection";
import { IgrGridSelectedCellRangesCollection } from "./igr-grid-selected-cell-ranges-collection";
import { GridSelectedItemsCollection as GridSelectedItemsCollection_internal } from "./GridSelectedItemsCollection";
import { GridSelectedKeysCollection as GridSelectedKeysCollection_internal } from "./GridSelectedKeysCollection";
import { GridSelectedCellsCollection as GridSelectedCellsCollection_internal } from "./GridSelectedCellsCollection";
import { GridSelectedCellRangesCollection as GridSelectedCellRangesCollection_internal } from "./GridSelectedCellRangesCollection";
import { IgrColumnHiddenChangedEventArgs } from "./igr-column-hidden-changed-event-args";
import { PrimaryKeyValue } from "./PrimaryKeyValue";
import { CellKey } from "./CellKey";
import { CellRange } from "./CellRange";
import { IgrGridFilterExpressionsEventArgs } from './igr-grid-filter-expressions-event-args';
import { GridColumnCollection as GridColumnCollection_internal } from './GridColumnCollection';
import { ResponsiveStatesCollection as ResponsiveStatesCollection_internal } from './ResponsiveStatesCollection';
import { IgrResponsiveStatesCollection } from './igr-responsive-states-collection';
import { ResponsiveState } from './ResponsiveState';
import { IgrGridAnimationSettings } from './igr-grid-animation-settings';
import { IgrRowSeparator } from './igr-row-separator';
import { IgrHeaderRowSeparator } from './igr-header-row-separator';
import { ContentChildrenManager } from "igniteui-react-core";
import { IgrGridCellPosition } from "./igr-grid-cell-position";
import { IgrGridActiveCellChangedEventArgs } from "./igr-grid-active-cell-changed-event-args";
import { DataGridScrollerKeyboardListener } from "./DataGridScrollerKeyboardListener";
import { IgrHeaderSeparator } from "./igr-header-separator";
import { IgrColumnResizingSeparator } from "./igr-column-resizing-separator";
import { ColumnResizingMode_$type } from "./ColumnResizingMode";
import { ColumnResizingAnimationMode_$type } from "./ColumnResizingAnimationMode";
import { ColumnMovingMode_$type } from "./ColumnMovingMode";
import { IgrColumnMovingSeparator } from "./igr-column-moving-separator";
import { SortIndicatorStyle_$type } from "./SortIndicatorStyle";
import { DataSourceSectionHeaderDisplayMode_$type } from "igniteui-react-core";
import { DataSourceSummaryScope_$type } from "igniteui-react-core";
import { GroupSummaryDisplayMode_$type } from "./GroupSummaryDisplayMode";
import { IgrPinnedAreaSeparator } from "./igr-pinned-area-separator";
import { fromRect } from "igniteui-react-core";
import { ColumnOptionsIconAlignment_$type } from "./ColumnOptionsIconAlignment";
import { ColumnOptionsIconBehavior_$type } from "./ColumnOptionsIconBehavior";
import { IgrColumnPinnedChangedEventArgs } from "./igr-column-pinned-changed-event-args";
import { ControlDisplayDensity_$type } from "igniteui-react-core";
import { CornerRadius } from "igniteui-react-core";
import { EditModeType_$type } from "./EditModeType";
import { EditModeClickAction_$type } from "./EditModeClickAction";
import { IgrGridCellValueChangingEventArgs } from "./igr-grid-cell-value-changing-event-args";
import { IgrGridDataCommittingEventArgs } from "./igr-grid-data-committing-event-args";
import { IgrGridDataCommittedEventArgs } from "./igr-grid-data-committed-event-args";
import { IgrGridSizeChangedEventArgs } from "./igr-grid-size-changed-event-args";
import { IgrGridColumnWidthChangedEventArgs } from "./igr-grid-column-width-changed-event-args";
import { DataGridAccessibilityLayoutPanel } from './DataGridAccessibilityLayoutPanel';
import { IgrGridCellEditStartedEventArgs } from "./igr-grid-cell-edit-started-event-args";
import { IgrGridCellEditEndedEventArgs } from "./igr-grid-cell-edit-ended-event-args";
import { IgrGridRowEditStartedEventArgs } from "./igr-grid-row-edit-started-event-args";
import { IgrGridRowEditEndedEventArgs } from "./igr-grid-row-edit-ended-event-args";
let GridStylingDefaults = {};
export class IgrDataGrid extends React.Component {
    constructor(props) {
        super(props);
        this.contentColumns = [];
        /**
         * The columns actually present in the grid. Do not directly modify this array.
         * This array's contents can be modified by causing React to reproject the child content.
         * Or adding and removing columns from the manual columns collection on the columns property.
         */
        this.combinedColumns = [];
        this._columns = null;
        this._disableManualColumnSync = false;
        this._scrollerStyle = 1 /* Fading */;
        this._columnsAdapter = null;
        this._renderer = null;
        this._scroller = null;
        this._dragger = null;
        this._wrapper = null;
        this._grid = null;
        this._dataSource = null;
        this._insetLeft = 0;
        this._insetTop = 0;
        this._insetRight = 0;
        this._insetBottom = 0;
        this._selectedItems = null;
        this._selectedKeys = null;
        this._selectedCells = null;
        this._selectedCellRanges = null;
        this._pinnedItems = null;
        this._pinnedKeys = null;
        this._responsiveStates = null;
        this._actualColumns = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._filterExpressionsChanging = null;
        this._filterExpressionsChanging_wrapped = null;
        this._filterExpressionsChanged = null;
        this._filterExpressionsChanged_wrapped = null;
        this._cellPreviewPointerDown = null;
        this._cellPreviewPointerDown_wrapped = null;
        this._cellPreviewPointerUp = null;
        this._cellPreviewPointerUp_wrapped = null;
        this._cellPointerDown = null;
        this._cellPointerDown_wrapped = null;
        this._cellPointerUp = null;
        this._cellPointerUp_wrapped = null;
        this._cellClicked = null;
        this._cellClicked_wrapped = null;
        this._sortDescriptionsChanged = null;
        this._sortDescriptionsChanged_wrapped = null;
        this._groupDescriptionsChanged = null;
        this._groupDescriptionsChanged_wrapped = null;
        this._columnHiddenChanged = null;
        this._columnHiddenChanged_wrapped = null;
        this._columnPinnedChanged = null;
        this._columnPinnedChanged_wrapped = null;
        this._cellValueChanging = null;
        this._cellValueChanging_wrapped = null;
        this._dataCommitted = null;
        this._dataCommitted_wrapped = null;
        this._dataCommitting = null;
        this._dataCommitting_wrapped = null;
        this._sizeChanged = null;
        this._sizeChanged_wrapped = null;
        this._actualColumnsChanged = null;
        this._actualColumnsChanged_wrapped = null;
        this._columnsAutoGenerated = null;
        this._columnsAutoGenerated_wrapped = null;
        this._selectedItemsChanged = null;
        this._selectedItemsChanged_wrapped = null;
        this._selectedKeysChanged = null;
        this._selectedKeysChanged_wrapped = null;
        this._selectedCellsChanged = null;
        this._selectedCellsChanged_wrapped = null;
        this._activeCellChanged = null;
        this._activeCellChanged_wrapped = null;
        this._selectedCellRangesChanged = null;
        this._selectedCellRangesChanged_wrapped = null;
        this._columnWidthChanged = null;
        this._columnWidthChanged_wrapped = null;
        this._cellEditStarted = null;
        this._cellEditStarted_wrapped = null;
        this._cellEditEnded = null;
        this._cellEditEnded_wrapped = null;
        this._rowEditStarted = null;
        this._rowEditStarted_wrapped = null;
        this._rowEditEnded = null;
        this._rowEditEnded_wrapped = null;
        this._actualPrimaryKeyChange = null;
        this._actualPrimaryKeyChange_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        this._getFilterDialog = this._getFilterDialog.bind(this);
        this._contentChildrenManager = new ContentChildrenManager((ch) => ch.props.name || ch.key || ch.props.field, (ch) => ch.name || ch.key || ch.field, () => this._updateContentChildren());
        let useCanvas = false;
        if (props.useCanvas) {
            this.useCanvas = true;
            useCanvas = true;
        }
        if (props.useAccessibility) {
            this.useAccessibility = true;
        }
        if (document) {
            this._container = document.createElement("div");
            this._container.style.display = "block";
            this._container.style.width = "100%";
            this._container.style.height = "100%";
            this._container.style.boxSizing = "border-box";
        }
        var root;
        root = this._container;
        this.requestRender = this.requestRender.bind(this);
        this._portalManager = new PortalManager("filterDialog", this.requestRender);
        this._portalManager.disableContentPortal = true;
        this._renderer = new ReactRenderer(root, document, true, DataGridStylingDefaults, this._portalManager);
        this._wrapper = this._renderer;
        this._implementation = new Grid();
        var grid = this.i;
        this._grid = grid;
        this._columnsAdapter = new CollectionAdapter(this.contentColumns, this.i.columns, this.combinedColumns, (c) => c.i, (i) => {
            i._provideRenderer(this._wrapper);
            if (this._container && this._container.parentElement) {
                i._styling(this._container, this, this);
            }
        }, (i) => { i._provideRenderer(null); }, (i) => { return i.name || i.field; });
        grid.externalGrid = new GridExternalWrapper(this);
        grid.tickProvider = new BrowserTickProvider(this._renderer);
        grid.platformPixelConverter = new BrowserPixelConverter();
        if (this.useAccessibility) {
            this._contentLayout = new DataGridAccessibilityLayoutPanel(this._renderer, new DataGridPresenterManager(this._grid, false), window.devicePixelRatio);
        }
        else {
            this._contentLayout = new DataGridCellLayoutPanel(this._renderer, new DataGridPresenterManager(this._grid, useCanvas), window.devicePixelRatio);
        }
        grid.renderingEngine = this._contentLayout;
        grid.viewportManager = new DataGridViewportManager(this);
        grid.delayedExecutionManager = new DataGridDelayedExecutionManager(this._renderer);
        grid.propertySetter = new DataGridPropertySetter();
        //grid.provideContainer(ren);
        let scroller = new Scroller();
        scroller.scrollbarStyle = this.scrollbarStyle;
        this._scroller = scroller;
        this._scroller.keyboardListener = new DataGridScrollerKeyboardListener(grid);
        scroller.provideContainer(this._renderer);
        this._content = (this._contentLayout.element.getNativeElement());
        scroller.provideContent(new ReactWrapper(this._content, this._renderer));
        scroller.onScrolling = () => this.onScroll();
        scroller.onScrollStart = () => this.onScrollStart();
        scroller.onScrollStop = () => this.onScrollStop();
        scroller.viewportWidth = this._container.clientWidth;
        scroller.viewportHeight = this._container.clientHeight;
        grid.dragger = new Dragger();
        grid.dragger.provideContainer(this._renderer);
        grid.dragger.viewportWidth = this._container.clientWidth;
        grid.dragger.viewportHeight = this._container.clientHeight;
        this.initializeProperties();
        scroller.verticalTrackStartInset = this.actualHeaderHeight;
        this._renderer.addSizeWatcher(() => {
            this.containerResized();
        });
    }
    _insertExternalColumnAtIndex(index, column) {
        //let contentCount = this.contentColumns.length;
        let contentCount = this._columnsAdapter.actualContent.length;
        this.columns.insert(index - contentCount, column);
    }
    _removeExternalColumn(column) {
        let ind = -1;
        for (let i = 0; i < this.columns.count; i++) {
            if (this.columns.item(i) === column) {
                ind = i;
                break;
            }
        }
        if (ind >= 0) {
            this.columns.removeAt(ind);
        }
    }
    _updateContentChildren() {
        this.contentColumns.length = 0;
        let contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (let i = 0; i < contentChildrenActual.length; i++) {
            if ((Column.$type).isAssignableFrom(contentChildrenActual[i].i.$type)) {
                if (!contentChildrenActual[i]._iniailizedMarkup) {
                    contentChildrenActual[i]._iniailizedMarkup = true;
                    contentChildrenActual[i].isFromMarkup = true;
                }
                this.contentColumns.push(contentChildrenActual[i]);
            }
        }
        if (this._columnsAdapter !== null) {
            this._columnsAdapter.notifyContentChanged();
        }
    }
    get actualDataSource() {
        return this.i.actualDataSource;
    }
    _getMainRef(ref) {
        this._elRef = ref;
        this.i.syncBorder();
        this._contentLayout.rootElement = this._elRef;
    }
    _getFilterDialog(ref) {
        this._filterDialogRef = ref;
    }
    _ensureColumnsAreManual() {
        this._disableManualColumnSync = true;
        this._columnsAdapter.shiftContentToManual(this.columns, (i) => i.isFromMarkup = false);
        this._disableManualColumnSync = false;
    }
    /**
     * A collection or manually added columns for the grid.
    */
    get columns() {
        if (this._columns === null) {
            let coll = new IgrGridColumnCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                if (this._disableManualColumnSync) {
                    return;
                }
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._columnsAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._columnsAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._columnsAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._columnsAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._columnsAdapter.clearManualItems();
                        break;
                }
            });
            this._columns = coll;
        }
        return this._columns;
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this.containerResized();
        }
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.width = value;
            this.containerResized();
        }
    }
    get width() {
        return this._width;
    }
    set useCanvas(value) {
        this._useCanvas = ensureBool(value);
    }
    get useCanvas() {
        return this._useCanvas;
    }
    set useAccessibility(value) {
        this._useAccessibility = ensureBool(value);
    }
    get useAccessibility() {
        return this._useAccessibility;
    }
    get scrollbarStyle() {
        return this._scrollerStyle;
    }
    set scrollbarStyle(style) {
        this._scrollerStyle = ensureEnum(ScrollbarStyle_$type, style);
        if (this._scroller) {
            this._scroller.scrollbarStyle = this._scrollerStyle;
        }
    }
    render() {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        let children = this._contentChildrenManager.getChildren(this.props.children);
        this._portalManager.onRender(children);
        let div = React.createElement("div", {
            className: "ig-data-grid igr-data-grid",
            ref: this._getMainRef,
            style: { boxSizing: "border-box", overflow: "hidden" },
            children: children
        });
        return div;
        //}
    }
    componentDidMount() {
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container);
        this.containerResized();
        this.initializeContent();
    }
    createImplementation() {
        let test = Grid;
        return new Grid();
    }
    ngOnInit() {
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    requestRender() {
        this.setState({});
    }
    _focusScroller() {
        this._scroller.focus();
    }
    _setDefaultCursor() {
        if (this._elRef.style.cursor !== "") {
            this._elRef.style.cursor = "";
        }
    }
    _setResizeCursor() {
        if (this._elRef.style.cursor !== "col-resize") {
            this._elRef.style.cursor = "col-resize";
        }
    }
    _setHandCursor() {
        if (this._elRef.style.cursor !== "grabbing") {
            this._elRef.style.cursor = "grabbing";
        }
    }
    _setBorder(borderColor, borderLeft, borderTop, borderRight, borderBottom, radiusTopLeft, radiusTopRight, radiusBottomLeft, radiusBottomRight) {
        if (this._elRef) {
            if (borderLeft !== 0 || borderTop !== 0 || borderRight !== 0 || borderBottom !== 0) {
                this._elRef.style.borderStyle = "solid";
                this._elRef.style.borderColor = borderColor;
                this._elRef.style.borderTopWidth = borderTop + "px";
                this._elRef.style.borderRightWidth = borderRight + "px";
                this._elRef.style.borderBottomWidth = borderBottom + "px";
                this._elRef.style.borderLeftWidth = borderLeft + "px";
                this._elRef.style.borderTopLeftRadius = radiusTopLeft + "px";
                this._elRef.style.borderTopRightRadius = radiusTopRight + "px";
                this._elRef.style.borderBottomLeftRadius = radiusBottomLeft + "px";
                this._elRef.style.borderBottomRightRadius = radiusBottomRight + "px";
            }
            else {
                this._elRef.style.borderStyle = "none";
            }
        }
    }
    _setScrollerVerticalTrackInset(inset) {
        this._scroller.verticalTrackStartInset = inset;
    }
    initializeContent() {
        // supports themes or custom properties set in CSS 
        let prev = this._grid.columnPropertyUpdatingAnimationMode;
        this._grid.columnPropertyUpdatingAnimationMode = ColumnPropertyUpdatingAnimationMode.None;
        this._styling(this._container, this);
        this._grid.columnPropertyUpdatingAnimationMode = prev;
        this._updateContentChildren();
        prev = this._grid.columnPropertyUpdatingAnimationMode;
        this._grid.columnPropertyUpdatingAnimationMode = ColumnPropertyUpdatingAnimationMode.None;
        for (let i = 0; i < this.actualColumns.count; i++) {
            let c = this.actualColumns.item(i);
            c._styling(this._container, this, this);
        }
        this._grid.columnPropertyUpdatingAnimationMode = prev;
        this._grid.itemsSource = this._dataSource;
    }
    componentWillUnmount() {
        //this._grid.destroy();
        this._wrapper.destroy();
    }
    initializeProperties() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    containerResized() {
        var width = this._container.clientWidth;
        var height = this._container.clientHeight;
        this._scroller.viewportWidth = width;
        this._scroller.viewportHeight = height;
        this._grid.dragger.viewportWidth = width;
        this._grid.dragger.viewportHeight = height;
        this._grid.onSizeChanged(width, height);
        if (this._grid.model.actualVisibleRegion.isEmpty &&
            width > 0 && height > 0) {
            this._grid.setViewport(0, 0, width, height);
        }
        else {
            this.onScroll();
        }
    }
    ;
    refreshContentSize() {
        if (this._content != null) {
            var width = this._grid.model.absoluteWidth;
            var height = this._grid.model.absoluteHeight;
            if (this._scroller != null) {
                this._scroller.contentWidth = width;
                this._scroller.contentHeight = height;
            }
        }
    }
    onScroll() {
        let top = this._scroller.scrollTop;
        let left = this._scroller.scrollLeft;
        let width = this._scroller.viewportWidth;
        let height = this._scroller.viewportHeight;
        //console.log("top:" + top);
        this._grid.setViewport(left, top, left + width, top + height);
    }
    onScrollStart() {
        this._grid.notifyScrollStart();
    }
    onScrollStop() {
        this._grid.notifyScrollStop();
    }
    scrollTo(x, y) {
        this._scroller.scrollTo(x, y);
        //let width = this._scroller.viewportWidth;
        //let height = this._scroller.viewportHeight;
        //this._grid.setViewport(x, y, x + width, y + height);
    }
    set dataSource(value) {
        this._dataSource = value;
        if (this._grid != null) {
            this._grid.itemsSource = this._dataSource;
        }
    }
    get dataSource() {
        return this._dataSource;
    }
    forColumnsWithPropertyPath(propertyPath, callback) {
        for (let i = 0; i < this.i.actualColumns.count; i++) {
            let col = this.i.actualColumns.item(i).externalObject;
            if (col.field == propertyPath) {
                callback(col);
            }
        }
    }
    /**
     * Gets or sets the default column width to use if a column as no local width.
     * */
    get defaultColumnWidth() {
        let ext = this.i.defaultColumnWidth.externalObject;
        if (!ext) {
            ext = new IgrColumnWidth();
            ext._implementation = this.i.defaultColumnWidth;
        }
        return ext;
    }
    set defaultColumnWidth(value) {
        if (typeof value == "string") {
            let int = ColumnWidth_internal.parse(value);
            let ext = new IgrColumnWidth();
            ext._implementation = int;
            value = ext;
        }
        this.i.defaultColumnWidth = value.i;
    }
    /**
     * Gets or sets the amount of left inset space to use around the grid content.
    */
    get insetLeft() {
        return this._insetLeft;
    }
    set insetLeft(v) {
        this._insetLeft = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }
    /**
     * Gets or sets the amount of top inset space to use around the grid content.
    */
    get insetTop() {
        return this._insetTop;
    }
    set insetTop(v) {
        this._insetTop = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }
    /**
     * Gets or sets the amount of right inset space to use around the grid content.
    */
    get insetRight() {
        return this._insetLeft;
    }
    set insetRight(v) {
        this._insetRight = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }
    /**
     * Gets or sets the amount of bottom inset space to use around the grid content.
    */
    get insetBottom() {
        return this._insetBottom;
    }
    set insetBottom(v) {
        this._insetBottom = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }
    /**
 * Gets or sets the type of column resizing to use.
*/
    get columnResizingMode() {
        return this.i.bu;
    }
    set columnResizingMode(v) {
        this.i.bu = ensureEnum(ColumnResizingMode_$type, v);
    }
    /**
     * Gets or sets the type column moving to use.
    */
    get columnMovingMode() {
        return this.i.bg;
    }
    set columnMovingMode(v) {
        this.i.bg = ensureEnum(ColumnMovingMode_$type, v);
    }
    /**
     * Gets or sets whether the row will highlight when hovered.
    */
    get isRowHoverEnabled() {
        return this.i.h4;
    }
    set isRowHoverEnabled(v) {
        this.i.h4 = ensureBool(v);
    }
    /**
     * Gets or sets the background color for rows when hovered.
    */
    get rowHoverBackground() {
        return brushToString(this.i.u7);
    }
    set rowHoverBackground(v) {
        this.i.u7 = stringToBrush(v);
    }
    /**
     * Gets or sets the border color for rows being edited.
    */
    get editRowBorder() {
        return brushToString(this.i.uz);
    }
    set editRowBorder(v) {
        this.i.uz = stringToBrush(v);
    }
    get editRowBorderWidthBottom() {
        return this.i.v0 ? this.i.v0.b : NaN;
    }
    set editRowBorderWidthBottom(v) {
        this.ensureEditRowBorderWidth();
        this.i.v0.b = +v;
        this.i.v0 = this.i.v0;
    }
    get editRowBorderWidthLeft() {
        return this.i.v0 ? this.i.v0.c : NaN;
    }
    set editRowBorderWidthLeft(v) {
        this.ensureEditRowBorderWidth();
        this.i.v0.c = +v;
        this.i.v0 = this.i.v0;
    }
    get editRowBorderWidthRight() {
        return this.i.v0 ? this.i.v0.d : NaN;
    }
    set editRowBorderWidthRight(v) {
        this.ensureEditRowBorderWidth();
        this.i.v0.d = +v;
        this.i.v0 = this.i.v0;
    }
    get editRowBorderWidthTop() {
        return this.i.v0 ? this.i.v0.e : NaN;
    }
    set editRowBorderWidthTop(v) {
        this.ensureEditRowBorderWidth();
        this.i.v0.e = +v;
        this.i.v0 = this.i.v0;
    }
    ensureEditRowBorderWidth() {
        if (this.i.v0) {
            return;
        }
        this.i.v0 = new Thickness(2);
    }
    /**
     * Gets or sets the header type used for sectioning off groups of rows.
    */
    get sectionHeader() {
        if (this.i.ey == null) {
            return null;
        }
        if (!this.i.ey.externalObject) {
            let e = IgrSectionHeader._createFromInternal(this.i.ey);
            if (e) {
                e._implementation = this.i.ey;
            }
            this.i.ey.externalObject = e;
        }
        return this.i.ey.externalObject;
    }
    set sectionHeader(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.ey = null : this.i.ey = v.i;
    }
    /**
     * Gets or sets the cell definition used for summary rows at the root level.
    */
    get summaryRowRoot() {
        if (this.i.e8 == null) {
            return null;
        }
        if (!this.i.e8.externalObject) {
            let e = IgrSummaryRowRoot._createFromInternal(this.i.e8);
            if (e) {
                e._implementation = this.i.e8;
            }
            this.i.e8.externalObject = e;
        }
        return this.i.e8.externalObject;
    }
    set summaryRowRoot(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.e8 = null : this.i.e8 = v.i;
    }
    /**
     * Gets or sets the cell definition used for summary rows at the section level.
    */
    get summaryRowSection() {
        if (this.i.fa == null) {
            return null;
        }
        if (!this.i.fa.externalObject) {
            let e = IgrSummaryRowSection._createFromInternal(this.i.fa);
            if (e) {
                e._implementation = this.i.fa;
            }
            this.i.fa.externalObject = e;
        }
        return this.i.fa.externalObject;
    }
    set summaryRowSection(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.fa = null : this.i.fa = v.i;
    }
    /**
     * Gets or sets the row seperator settings.
    */
    get rowSeparator() {
        if (this.i.eu == null) {
            return null;
        }
        if (!this.i.eu.externalObject) {
            let e = IgrRowSeparator._createFromInternal(this.i.eu);
            if (e) {
                e._implementation = this.i.eu;
            }
            this.i.eu.externalObject = e;
        }
        return this.i.eu.externalObject;
    }
    set rowSeparator(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.eu = null : this.i.eu = v.i;
    }
    /**
     * Gets or sets the header row seperator settings.
    */
    get headerRowSeparator() {
        if (this.i.d2 == null) {
            return null;
        }
        if (!this.i.d2.externalObject) {
            let e = IgrHeaderRowSeparator._createFromInternal(this.i.d2);
            if (e) {
                e._implementation = this.i.d2;
            }
            this.i.d2.externalObject = e;
        }
        return this.i.d2.externalObject;
    }
    set headerRowSeparator(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.d2 = null : this.i.d2 = v.i;
    }
    /**
     * Gets or sets the header seperator settings.
    */
    get headerSeparator() {
        if (this.i.d4 == null) {
            return null;
        }
        if (!this.i.d4.externalObject) {
            let e = IgrHeaderSeparator._createFromInternal(this.i.d4);
            if (e) {
                e._implementation = this.i.d4;
            }
            this.i.d4.externalObject = e;
        }
        return this.i.d4.externalObject;
    }
    set headerSeparator(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.d4 = null : this.i.d4 = v.i;
    }
    /**
     * Gets or sets the column resizing seperator settings.
    */
    get columnResizingSeparator() {
        if (this.i.bw == null) {
            return null;
        }
        if (!this.i.bw.externalObject) {
            let e = IgrColumnResizingSeparator._createFromInternal(this.i.bw);
            if (e) {
                e._implementation = this.i.bw;
            }
            this.i.bw.externalObject = e;
        }
        return this.i.bw.externalObject;
    }
    set columnResizingSeparator(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.bw = null : this.i.bw = v.i;
    }
    /**
     * Gets or sets the column resizing seperator settings.
    */
    get columnMovingSeparator() {
        if (this.i.bi == null) {
            return null;
        }
        if (!this.i.bi.externalObject) {
            let e = IgrColumnMovingSeparator._createFromInternal(this.i.bi);
            if (e) {
                e._implementation = this.i.bi;
            }
            this.i.bi.externalObject = e;
        }
        return this.i.bi.externalObject;
    }
    set columnMovingSeparator(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.bi = null : this.i.bi = v.i;
    }
    /**
     * Gets or sets the pinned area separator settings.
    */
    get pinnedAreaSeparator() {
        if (this.i.ei == null) {
            return null;
        }
        if (!this.i.ei.externalObject) {
            let e = IgrPinnedAreaSeparator._createFromInternal(this.i.ei);
            if (e) {
                e._implementation = this.i.ei;
            }
            this.i.ei.externalObject = e;
        }
        return this.i.ei.externalObject;
    }
    set pinnedAreaSeparator(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.ei = null : this.i.ei = v.i;
    }
    /**
     * Gets or sets the desired properties the grid will automatically generate columns for.
    */
    get autoGenerateDesiredProperties() {
        return this.i.f;
    }
    set autoGenerateDesiredProperties(v) {
        this.i.f = v;
    }
    /**
     * Gets or sets the desired properties for the data source to load. If specified the data source may decide to constrain the properties it fetches to these properties and must make sure that at least those properties are loaded, rather than the default behavior for that data source.
    */
    get dataSourceDesiredProperties() {
        return this.i.g;
    }
    set dataSourceDesiredProperties(v) {
        this.i.g = v;
    }
    /**
     * Gets or sets the display density to use for the grid.
    */
    get density() {
        return this.i.fg;
    }
    set density(v) {
        this.i.fg = ensureEnum(ControlDisplayDensity_$type, v);
    }
    /**
     * Gets the actual height for the rows in the grid.
    */
    get actualRowHeight() {
        return this.i.kl;
    }
    set actualRowHeight(v) {
        this.i.kl = +v;
    }
    /**
     * Gets or sets the height to use for the rows in the grid. If not set the grid will
     * use the default value for the set display density.
    */
    get rowHeight() {
        return this.i.le;
    }
    set rowHeight(v) {
        this.i.le = +v;
    }
    /**
     * Gets or sets the default minimum width to use on all columns. Ignored if NaN.
    */
    get defaultColumnMinWidth() {
        return this.i.jn;
    }
    set defaultColumnMinWidth(v) {
        this.i.jn = +v;
    }
    /**
     * Gets the height used for the header row.
    */
    get actualHeaderHeight() {
        return this.i.kk;
    }
    set actualHeaderHeight(v) {
        this.i.kk = +v;
    }
    /**
     * Gets or sets the height to use for the header row.
    */
    get headerHeight() {
        return this.i.k6;
    }
    set headerHeight(v) {
        this.i.k6 = +v;
    }
    /**
     * Returns/sets the action to take when a column header is clicked.
    */
    get headerClickAction() {
        return this.i.d0;
    }
    set headerClickAction(v) {
        this.i.d0 = ensureEnum(HeaderClickAction_$type, v);
    }
    /**
     * Gets or sets the type of edit mode
    */
    get editMode() {
        return this.i.cf;
    }
    set editMode(v) {
        this.i.cf = ensureEnum(EditModeType_$type, v);
    }
    /**
     * Gets or sets the type of click action required to enter edit mode.
    */
    get editModeClickAction() {
        return this.i.cd;
    }
    set editModeClickAction(v) {
        this.i.cd = ensureEnum(EditModeClickAction_$type, v);
    }
    /**
     * Configures whether or not the grid will autogenerate columns when the data source is set.
    */
    get autoGenerateColumns() {
        return this.i.g3;
    }
    set autoGenerateColumns(v) {
        this.i.g3 = ensureBool(v);
    }
    /**
     * Sets or gets the height to use for the row separators.
    */
    get rowSeparatorHeight() {
        return this.i.lg;
    }
    set rowSeparatorHeight(v) {
        this.i.lg = +v;
    }
    /**
     * Configures whether or not place holders are used for cells who do not have their data yet.
    */
    get isPlaceholderRenderingEnabled() {
        return this.i.hy;
    }
    set isPlaceholderRenderingEnabled(v) {
        this.i.hy = ensureBool(v);
    }
    /**
     * Sets or gets the Column Adding Animation mode to use.
    */
    get columnAddingAnimationMode() {
        return this.i.bz;
    }
    set columnAddingAnimationMode(v) {
        this.i.bz = ensureEnum(ColumnShowingAnimationMode_$type, v);
    }
    /**
     * Sets or gets the Column Property Updating Animation mode to use.
    */
    get columnPropertyUpdatingAnimationMode() {
        return this.i.columnPropertyUpdatingAnimationMode;
    }
    set columnPropertyUpdatingAnimationMode(v) {
        this.i.columnPropertyUpdatingAnimationMode = ensureEnum(ColumnPropertyUpdatingAnimationMode_$type, v);
    }
    /**
     * Sets or gets the cell data loaded animation mode to use.
    */
    get cellDataLoadedAnimationMode() {
        return this.i.al;
    }
    set cellDataLoadedAnimationMode(v) {
        this.i.al = ensureEnum(CellDataLoadedAnimationMode_$type, v);
    }
    /**
     * Sets or gets the row selection animation mode to use.
    */
    get rowSelectionAnimationMode() {
        return this.i.es;
    }
    set rowSelectionAnimationMode(v) {
        this.i.es = ensureEnum(RowSelectionAnimationMode_$type, v);
    }
    /**
     * Sets or gets the row hover animation mode to use.
    */
    get rowHoverAnimationMode() {
        return this.i.ep;
    }
    set rowHoverAnimationMode(v) {
        this.i.ep = ensureEnum(RowHoverAnimationMode_$type, v);
    }
    /**
     * Sets or gets the cell selection animation mode to use.
    */
    get cellSelectionAnimationMode() {
        return this.i.aw;
    }
    set cellSelectionAnimationMode(v) {
        this.i.aw = ensureEnum(CellSelectionAnimationMode_$type, v);
    }
    /**
     * Sets or gets the default animation settings for the grid.
    */
    get animationSettings() {
        if (this.i.cm == null) {
            return null;
        }
        if (!this.i.cm.externalObject) {
            let e = new IgrGridAnimationSettings();
            e._implementation = this.i.cm;
            this.i.cm.externalObject = e;
        }
        return this.i.cm.externalObject;
    }
    set animationSettings(v) {
        v == null ? this.i.cm = null : this.i.cm = v.i;
    }
    /**
     * Sets or gets the column resizing animation mode to use. Only applies when resizing in Deferred mode.
    */
    get columnResizingAnimationMode() {
        return this.i.br;
    }
    set columnResizingAnimationMode(v) {
        this.i.br = ensureEnum(ColumnResizingAnimationMode_$type, v);
    }
    /**
     * Sets or gets the column showing animation mode to use.
    */
    get columnShowingAnimationMode() {
        return this.i.b0;
    }
    set columnShowingAnimationMode(v) {
        this.i.b0 = ensureEnum(ColumnShowingAnimationMode_$type, v);
    }
    /**
     * Sets or gets the column moving animation mode to use.
    */
    get columnMovingAnimationMode() {
        return this.i.bd;
    }
    set columnMovingAnimationMode(v) {
        this.i.bd = ensureEnum(ColumnMovingAnimationMode_$type, v);
    }
    /**
     * Sets or gets the column hiding animation mode to use.
    */
    get columnHidingAnimationMode() {
        return this.i.ba;
    }
    set columnHidingAnimationMode(v) {
        this.i.ba = ensureEnum(ColumnHidingAnimationMode_$type, v);
    }
    /**
     * Sets or gets the column exchanging animation mode to use.
    */
    get columnExchangingAnimationMode() {
        return this.i.a4;
    }
    set columnExchangingAnimationMode(v) {
        this.i.a4 = ensureEnum(ColumnExchangingAnimationMode_$type, v);
    }
    /**
     * Sets or gets the grid selection mode.
    */
    get selectionMode() {
        return this.i.dt;
    }
    set selectionMode(v) {
        this.i.dt = ensureEnum(GridSelectionMode_$type, v);
    }
    /**
     * Sets or gets the grid selection mode.
    */
    get activationMode() {
        return this.i.ch;
    }
    set activationMode(v) {
        this.i.ch = ensureEnum(GridActivationMode_$type, v);
    }
    /**
     * Sets or gets how selection behaves in the grid.
    */
    get selectionBehavior() {
        return this.i.dr;
    }
    set selectionBehavior(v) {
        this.i.dr = ensureEnum(GridSelectionBehavior_$type, v);
    }
    /**
     * Gets which items are currently selected in the grid. Collection can be updated to programatically select items.
    */
    get selectedItems() {
        if (this._selectedItems === null) {
            let coll = new IgrGridSelectedItemsCollection();
            let innerColl = this.i.ad;
            if (!innerColl) {
                innerColl = new GridSelectedItemsCollection_internal();
            }
            this._selectedItems = coll._fromInner(innerColl);
        }
        return this._selectedItems;
    }
    set selectedItems(v) {
        if (this._selectedItems !== null) {
            this._selectedItems._setSyncTarget(null);
            this._selectedItems = null;
        }
        let coll = new IgrGridSelectedItemsCollection();
        this._selectedItems = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(Base.$type);
        let innerColl = this.i.ad;
        if (!innerColl) {
            innerColl = new GridSelectedItemsCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._selectedItems._setSyncTarget(syncColl);
    }
    /**
     * Gets which primary key values are currently selected in the grid. Collection can be updated to programatically select items.
    */
    get selectedKeys() {
        if (this._selectedKeys === null) {
            let coll = new IgrGridSelectedKeysCollection();
            let innerColl = this.i.ah;
            if (!innerColl) {
                innerColl = new GridSelectedKeysCollection_internal();
            }
            this._selectedKeys = coll._fromInner(innerColl);
        }
        return this._selectedKeys;
    }
    set selectedKeys(v) {
        if (this._selectedKeys !== null) {
            this._selectedKeys._setSyncTarget(null);
            this._selectedKeys = null;
        }
        let coll = new IgrGridSelectedKeysCollection();
        this._selectedKeys = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(PrimaryKeyValue.$type);
        let innerColl = this.i.ah;
        if (!innerColl) {
            innerColl = new GridSelectedKeysCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._selectedKeys._setSyncTarget(syncColl);
    }
    /**
     * Gets which cells are currently selected in the grid. Collection can be updated to programatically select cells.
    */
    get selectedCells() {
        if (this._selectedCells === null) {
            let coll = new IgrGridSelectedCellsCollection();
            let innerColl = this.i.dm;
            if (!innerColl) {
                innerColl = new GridSelectedCellsCollection_internal();
            }
            this._selectedCells = coll._fromInner(innerColl);
        }
        return this._selectedCells;
    }
    set selectedCells(v) {
        if (this._selectedCells !== null) {
            this._selectedCells._setSyncTarget(null);
            this._selectedCells = null;
        }
        let coll = new IgrGridSelectedCellsCollection();
        this._selectedCells = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(CellKey.$type);
        let innerColl = this.i.dm;
        if (!innerColl) {
            innerColl = new GridSelectedCellsCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._selectedCells._setSyncTarget(syncColl);
    }
    /**
     * Gets which cell ranges are currently selected in the grid. Collection can be updated to programatically select cells.
    */
    get selectedCellRanges() {
        if (this._selectedCellRanges === null) {
            let coll = new IgrGridSelectedCellRangesCollection();
            let innerColl = this.i.dj;
            if (!innerColl) {
                innerColl = new GridSelectedCellRangesCollection_internal();
            }
            this._selectedCellRanges = coll._fromInner(innerColl);
        }
        return this._selectedCellRanges;
    }
    set selectedCellRanges(v) {
        if (this._selectedCellRanges !== null) {
            this._selectedCellRanges._setSyncTarget(null);
            this._selectedCellRanges = null;
        }
        let coll = new IgrGridSelectedCellRangesCollection();
        this._selectedCellRanges = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(CellRange.$type);
        let innerColl = this.i.dj;
        if (!innerColl) {
            innerColl = new GridSelectedCellRangesCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._selectedCellRanges._setSyncTarget(syncColl);
    }
    /**
     * Gets which items are currently pinned in the grid. Collection can be updated to programatically pin items.
    */
    get pinnedItems() {
        if (this._pinnedItems === null) {
            let coll = new IgrGridSelectedItemsCollection();
            let innerColl = this.i.ac;
            if (!innerColl) {
                innerColl = new GridSelectedItemsCollection_internal();
            }
            this._pinnedItems = coll._fromInner(innerColl);
        }
        return this._pinnedItems;
    }
    set pinnedItems(v) {
        if (this._pinnedItems !== null) {
            this._pinnedItems._setSyncTarget(null);
            this._pinnedItems = null;
        }
        let coll = new IgrGridSelectedItemsCollection();
        this._pinnedItems = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(Base.$type);
        let innerColl = this.i.ac;
        if (!innerColl) {
            innerColl = new GridSelectedItemsCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._pinnedItems._setSyncTarget(syncColl);
    }
    /**
     * Gets which primary keys are currently pinned in the grid. Collection can be updated to programatically pin items.
    */
    get pinnedKeys() {
        if (this._pinnedKeys === null) {
            let coll = new IgrGridSelectedKeysCollection();
            let innerColl = this.i.ag;
            if (!innerColl) {
                innerColl = new GridSelectedKeysCollection_internal();
            }
            this._pinnedKeys = coll._fromInner(innerColl);
        }
        return this._pinnedKeys;
    }
    set pinnedKeys(v) {
        if (this._pinnedKeys !== null) {
            this._pinnedKeys._setSyncTarget(null);
            this._pinnedKeys = null;
        }
        let coll = new IgrGridSelectedKeysCollection();
        this._pinnedKeys = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(PrimaryKeyValue.$type);
        let innerColl = this.i.ag;
        if (!innerColl) {
            innerColl = new GridSelectedKeysCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._pinnedKeys._setSyncTarget(syncColl);
    }
    /**
     * Gets or sets whether to show the column options UI in the headers for columns.
    */
    get isColumnOptionsEnabled() {
        return this.i.hn;
    }
    set isColumnOptionsEnabled(v) {
        this.i.hn = ensureBool(v);
    }
    /**
     * Gets or sets if group rows will stick to the top of the grid.
    */
    get isGroupRowSticky() {
        return this.i.hu;
    }
    set isGroupRowSticky(v) {
        this.i.hu = ensureBool(v);
    }
    /**
     * Gets or sets if header separators are rendered.
    */
    get isHeaderSeparatorVisible() {
        return this.i.hv;
    }
    set isHeaderSeparatorVisible(v) {
        this.i.hv = ensureBool(v);
    }
    /**
     * Gets or sets the default background color to use for content cells when a row is in a selected state
    */
    get cellSelectedBackground() {
        return brushToString(this.i.ut);
    }
    set cellSelectedBackground(v) {
        this.i.ut = stringToBrush(v);
    }
    /**
     * Gets or sets the default background color to use for section header cells when a row is in a selected state
    */
    get sectionHeaderSelectedBackground() {
        return brushToString(this.i.vd);
    }
    set sectionHeaderSelectedBackground(v) {
        this.i.vd = stringToBrush(v);
    }
    /**
     * Gets or sets the default background color to use for summary cells at the root level.
    */
    get summaryRootBackground() {
        return brushToString(this.i.vg);
    }
    set summaryRootBackground(v) {
        this.i.vg = stringToBrush(v);
    }
    /**
     * Gets or sets the default background color to use for summary cells at the section level.
    */
    get summarySectionBackground() {
        return brushToString(this.i.vk);
    }
    set summarySectionBackground(v) {
        this.i.vk = stringToBrush(v);
    }
    /**
     * Gets or sets the default opacity to use for pinned rows
    */
    get pinnedRowOpacity() {
        return this.i.jp;
    }
    set pinnedRowOpacity(v) {
        this.i.jp = +v;
    }
    /**
     * Gets or sets the font to use for cells that have been edited.
    */
    get editTextStyle() {
        if (this.i.fq == null) {
            return null;
        }
        return this.i.fq.fontString;
    }
    set editTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fq = fi;
    }
    /**
     * Gets or sets the default opacity for unsaved cell edits.
    */
    get editOpacity() {
        return this.i.jo;
    }
    set editOpacity(v) {
        this.i.jo = +v;
    }
    /**
     * Gets or sets the text color for unsaved deleted rows.
    */
    get deletedTextColor() {
        return brushToString(this.i.uy);
    }
    set deletedTextColor(v) {
        this.i.uy = stringToBrush(v);
    }
    /**
     * Gets or sets the default color to use for sticky rows
    */
    get stickyRowBackground() {
        return brushToString(this.i.vf);
    }
    set stickyRowBackground(v) {
        this.i.vf = stringToBrush(v);
    }
    /**
     * Gets or sets the default color to use for pinned rows
    */
    get pinnedRowBackground() {
        return brushToString(this.i.u6);
    }
    set pinnedRowBackground(v) {
        this.i.u6 = stringToBrush(v);
    }
    /**
     * Gets or sets the default color to use for the last sticky row
    */
    get lastStickyRowBackground() {
        return brushToString(this.i.u5);
    }
    set lastStickyRowBackground(v) {
        this.i.u5 = stringToBrush(v);
    }
    /**
     * Gets or sets the position of the active cell.
    */
    get activeCell() {
        if (this.i.cw == null) {
            return null;
        }
        if (!this.i.cw.externalObject) {
            let e = new IgrGridCellPosition();
            e._implementation = this.i.cw;
            this.i.cw.externalObject = e;
        }
        return this.i.cw.externalObject;
    }
    set activeCell(v) {
        v == null ? this.i.cw = null : this.i.cw = v.i;
    }
    /**
     * Gets or sets the default background color to use for content cells
    */
    get cellBackground() {
        return brushToString(this.i.us);
    }
    set cellBackground(v) {
        this.i.us = stringToBrush(v);
    }
    /**
     * Gets or sets the default text color to use for content cells
    */
    get cellTextColor() {
        return brushToString(this.i.uu);
    }
    set cellTextColor(v) {
        this.i.uu = stringToBrush(v);
    }
    /**
     * Gets or sets the default text color to use for content cells
    */
    get headerSortIndicatorColor() {
        return brushToString(this.i.u3);
    }
    set headerSortIndicatorColor(v) {
        this.i.u3 = stringToBrush(v);
    }
    /**
     * Gets or sets the default render style for sort indicators in header cells.
    */
    get headerSortIndicatorStyle() {
        return this.i.e2;
    }
    set headerSortIndicatorStyle(v) {
        this.i.e2 = ensureEnum(SortIndicatorStyle_$type, v);
    }
    /**
     * Gets or sets the font to use for content cells
    */
    get cellTextStyle() {
        if (this.i.fp == null) {
            return null;
        }
        return this.i.fp.fontString;
    }
    set cellTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fp = fi;
    }
    /**
     * Gets or sets the default background color to use for section header cells
    */
    get sectionHeaderBackground() {
        return brushToString(this.i.vc);
    }
    set sectionHeaderBackground(v) {
        this.i.vc = stringToBrush(v);
    }
    /**
     * Gets or sets the default text color to use for section header cells
    */
    get sectionHeaderTextColor() {
        return brushToString(this.i.ve);
    }
    set sectionHeaderTextColor(v) {
        this.i.ve = stringToBrush(v);
    }
    /**
     * Gets or sets the font to use for section header cells
    */
    get sectionHeaderTextStyle() {
        if (this.i.fs == null) {
            return null;
        }
        return this.i.fs.fontString;
    }
    set sectionHeaderTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fs = fi;
    }
    /**
     * Gets or sets the font to use for summary labels at the root level.
    */
    get summaryRootLabelTextStyle() {
        if (this.i.ft == null) {
            return null;
        }
        return this.i.ft.fontString;
    }
    set summaryRootLabelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ft = fi;
    }
    /**
     * Gets or sets the font to use for summary labels at the section level.
    */
    get summarySectionLabelTextStyle() {
        if (this.i.fv == null) {
            return null;
        }
        return this.i.fv.fontString;
    }
    set summarySectionLabelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fv = fi;
    }
    /**
     * Gets or sets the default text color to use for summary cells at the root level.
    */
    get summaryRootValueTextColor() {
        return brushToString(this.i.vj);
    }
    set summaryRootValueTextColor(v) {
        this.i.vj = stringToBrush(v);
    }
    /**
     * Gets or sets the font to use for summary values at the root level.
    */
    get summaryRootValueTextStyle() {
        if (this.i.fu == null) {
            return null;
        }
        return this.i.fu.fontString;
    }
    set summaryRootValueTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fu = fi;
    }
    /**
     * Gets or sets the font to use for summary values at the section level.
    */
    get summarySectionValueTextStyle() {
        if (this.i.fw == null) {
            return null;
        }
        return this.i.fw.fontString;
    }
    set summarySectionValueTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fw = fi;
    }
    /**
     * Gets or sets the default text color to use for summary cells at the section level.
    */
    get summarySectionValueTextColor() {
        return brushToString(this.i.vn);
    }
    set summarySectionValueTextColor(v) {
        this.i.vn = stringToBrush(v);
    }
    /**
     * Gets or sets the default text color to use for summary labels in summary cells at the root level.
    */
    get summaryRootLabelTextColor() {
        return brushToString(this.i.vh);
    }
    set summaryRootLabelTextColor(v) {
        this.i.vh = stringToBrush(v);
    }
    /**
     * Gets or sets the default text color to use for summary labels in summary cells at the section level.
    */
    get summarySectionLabelTextColor() {
        return brushToString(this.i.vl);
    }
    set summarySectionLabelTextColor(v) {
        this.i.vl = stringToBrush(v);
    }
    /**
     * Gets or sets the default background color to use for summary cells at the root level.
    */
    get summaryRootSelectedBackground() {
        return brushToString(this.i.vi);
    }
    set summaryRootSelectedBackground(v) {
        this.i.vi = stringToBrush(v);
    }
    /**
     * Gets or sets the default background color to use for summary cells at the section level.
    */
    get summarySectionSelectedBackground() {
        return brushToString(this.i.vm);
    }
    set summarySectionSelectedBackground(v) {
        this.i.vm = stringToBrush(v);
    }
    /**
     * Gets or sets the width of the pinned area separators.
    */
    get pinnedAreaSeparatorWidth() {
        return this.i.lc;
    }
    set pinnedAreaSeparatorWidth(v) {
        this.i.lc = +v;
    }
    /**
     * Gets or sets the width of the header separators.
    */
    get headerSeparatorWidth() {
        return this.i.la;
    }
    set headerSeparatorWidth(v) {
        this.i.la = +v;
    }
    /**
     * Gets or sets the default background color to use for header separators.
    */
    get headerSeparatorBackground() {
        return brushToString(this.i.u2);
    }
    set headerSeparatorBackground(v) {
        this.i.u2 = stringToBrush(v);
    }
    /**
     * Gets or sets the default background color to use for header cells
    */
    get headerBackground() {
        return brushToString(this.i.u0);
    }
    set headerBackground(v) {
        this.i.u0 = stringToBrush(v);
    }
    /**
     * Gets or sets the default text color to use for header cells
    */
    get headerTextColor() {
        return brushToString(this.i.u4);
    }
    set headerTextColor(v) {
        this.i.u4 = stringToBrush(v);
    }
    /**
     * Gets or sets the font to use for header cells
    */
    get headerTextStyle() {
        if (this.i.fr == null) {
            return null;
        }
        return this.i.fr.fontString;
    }
    set headerTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fr = fi;
    }
    /**
     * Gets or sets the default background color to use for row separators
    */
    get rowSeparatorBackground() {
        return brushToString(this.i.u8);
    }
    set rowSeparatorBackground(v) {
        this.i.u8 = stringToBrush(v);
    }
    get headerRowSeparatorBackground() {
        return brushToString(this.i.u1);
    }
    set headerRowSeparatorBackground(v) {
        this.i.u1 = stringToBrush(v);
    }
    /**
     * Gets or sets the default sticky row background color to use for row separators
    */
    get rowSeparatorStickyRowBackground() {
        return brushToString(this.i.vb);
    }
    set rowSeparatorStickyRowBackground(v) {
        this.i.vb = stringToBrush(v);
    }
    /**
     * Gets or sets the default last sticky row background color to use for row separators
    */
    get rowSeparatorLastStickyRowBackground() {
        return brushToString(this.i.u9);
    }
    set rowSeparatorLastStickyRowBackground(v) {
        this.i.u9 = stringToBrush(v);
    }
    /**
     * Gets or sets the pinned row background color to use for row separators
    */
    get rowSeparatorPinnedRowBackground() {
        return brushToString(this.i.va);
    }
    set rowSeparatorPinnedRowBackground(v) {
        this.i.va = stringToBrush(v);
    }
    /**
     * Sets or gets the width to use for the column resizing separator.
    */
    get columnResizingSeparatorWidth() {
        return this.i.kp;
    }
    set columnResizingSeparatorWidth(v) {
        this.i.kp = +v;
    }
    /**
     * Sets or gets the width to use for the column resizing separator.
    */
    get columnMovingSeparatorWidth() {
        return this.i.kn;
    }
    set columnMovingSeparatorWidth(v) {
        this.i.kn = +v;
    }
    /**
     * Gets or sets the default background color to use for column resizing separator.
    */
    get columnResizingSeparatorBackground() {
        return brushToString(this.i.ux);
    }
    set columnResizingSeparatorBackground(v) {
        this.i.ux = stringToBrush(v);
    }
    /**
     * Gets or sets the default background color to use for column moving separator.
    */
    get columnMovingSeparatorBackground() {
        return brushToString(this.i.uv);
    }
    set columnMovingSeparatorBackground(v) {
        this.i.uv = stringToBrush(v);
    }
    /**
     * Gets or sets if the section header content should be shifted into the normal column scrollable area when there are pinned columns
    */
    get shiftSectionContent() {
        return this.i.iv;
    }
    set shiftSectionContent(v) {
        this.i.iv = ensureBool(v);
    }
    /**
     * Gets or sets the column options icon alignment in header cells.
    */
    get columnOptionsIconAlignment() {
        return this.i.bk;
    }
    set columnOptionsIconAlignment(v) {
        this.i.bk = ensureEnum(ColumnOptionsIconAlignment_$type, v);
    }
    /**
     * Gets or sets the column options icon color in header cells.
    */
    get columnOptionsIconColor() {
        return brushToString(this.i.uw);
    }
    set columnOptionsIconColor(v) {
        this.i.uw = stringToBrush(v);
    }
    /**
     * Gets or sets how the column options icon will behave inside header cells.
    */
    get columnOptionsIconBehavior() {
        return this.i.bm;
    }
    set columnOptionsIconBehavior(v) {
        this.i.bm = ensureEnum(ColumnOptionsIconBehavior_$type, v);
    }
    /**
     * Gets or sets the border color around the grid.
    */
    get border() {
        return brushToString(this.i.border);
    }
    set border(v) {
        this.i.border = stringToBrush(v);
    }
    /**
     * Gets the actual border width.
    */
    get actualBorderWidth() {
        return this.i.vw;
    }
    set actualBorderWidth(v) {
        this.i.vw = v;
    }
    get borderWidthBottom() {
        return this.i.vx ? this.i.vx.b : NaN;
    }
    set borderWidthBottom(v) {
        this.ensureBorderWidth();
        this.i.vx.b = +v;
        this.i.vx = this.i.vx;
    }
    get borderWidthLeft() {
        return this.i.vx ? this.i.vx.c : NaN;
    }
    set borderWidthLeft(v) {
        this.ensureBorderWidth();
        this.i.vx.c = +v;
        this.i.vx = this.i.vx;
    }
    get borderWidthRight() {
        return this.i.vx ? this.i.vx.d : NaN;
    }
    set borderWidthRight(v) {
        this.ensureBorderWidth();
        this.i.vx.d = +v;
        this.i.vx = this.i.vx;
    }
    get borderWidthTop() {
        return this.i.vx ? this.i.vx.e : NaN;
    }
    set borderWidthTop(v) {
        this.ensureBorderWidth();
        this.i.vx.e = +v;
        this.i.vx = this.i.vx;
    }
    ensureBorderWidth() {
        if (this.i.vx) {
            return;
        }
        this.i.vx = new Thickness(2);
    }
    /**
     * Gets or sets if the grid should notify on programmatic selection changes as well as changes from the UI.
    */
    get notifyOnAllSelectionChanges() {
        return this.i.h7;
    }
    set notifyOnAllSelectionChanges(v) {
        this.i.h7 = ensureBool(v);
    }
    get cornerRadiusBottomRight() {
        return this.i.ts ? this.i.ts.b : NaN;
    }
    set cornerRadiusBottomRight(v) {
        this.ensureCornerRadius();
        this.i.ts.b = +v;
        this.i.ts = this.i.ts;
    }
    get cornerRadiusBottomLeft() {
        return this.i.ts ? this.i.ts.a : NaN;
    }
    set cornerRadiusBottomLeft(v) {
        this.ensureCornerRadius();
        this.i.ts.a = +v;
        this.i.ts = this.i.ts;
    }
    get cornerRadiusTopLeft() {
        return this.i.ts ? this.i.ts.c : NaN;
    }
    set cornerRadiusTopLeft(v) {
        this.ensureCornerRadius();
        this.i.ts.c = +v;
        this.i.ts = this.i.ts;
    }
    get cornerRadiusTopRight() {
        return this.i.ts ? this.i.ts.d : NaN;
    }
    set cornerRadiusTopRight(v) {
        this.ensureCornerRadius();
        this.i.ts.d = +v;
        this.i.ts = this.i.ts;
    }
    ensureCornerRadius() {
        if (this.i.ts) {
            return;
        }
        this.i.ts = new CornerRadius(2);
    }
    get actualCornerRadiusBottomRight() {
        return this.i.tq ? this.i.tq.b : NaN;
    }
    set actualCornerRadiusBottomRight(v) {
        this.ensureActualCornerRadius();
        this.i.tq.b = +v;
        this.i.tq = this.i.tq;
    }
    get actualCornerRadiusBottomLeft() {
        return this.i.tq ? this.i.tq.a : NaN;
    }
    set actualCornerRadiusBottomLeft(v) {
        this.ensureActualCornerRadius();
        this.i.tq.a = +v;
        this.i.tq = this.i.tq;
    }
    get actualCornerRadiusTopLeft() {
        return this.i.tq ? this.i.tq.c : NaN;
    }
    set actualCornerRadiusTopLeft(v) {
        this.ensureActualCornerRadius();
        this.i.tq.c = +v;
        this.i.tq = this.i.tq;
    }
    get actualCornerRadiusTopRight() {
        return this.i.tq ? this.i.tq.d : NaN;
    }
    set actualCornerRadiusTopRight(v) {
        this.ensureActualCornerRadius();
        this.i.tq.d = +v;
        this.i.tq = this.i.tq;
    }
    ensureActualCornerRadius() {
        if (this.i.tq) {
            return;
        }
        this.i.tq = new CornerRadius(2);
    }
    /**
     * Gets or sets whether the active cell style will be applied to cells when made active.
    */
    get isActiveCellStyleEnabled() {
        return this.i.he;
    }
    set isActiveCellStyleEnabled(v) {
        this.i.he = ensureBool(v);
    }
    /**
     * A set of states that can be applied to the columns of the grid based on available space.
    */
    get responsiveStates() {
        if (this._responsiveStates === null) {
            let coll = new IgrResponsiveStatesCollection();
            let innerColl = this.i.en;
            if (!innerColl) {
                innerColl = new ResponsiveStatesCollection_internal();
            }
            this._responsiveStates = coll._fromInner(innerColl);
        }
        return this._responsiveStates;
    }
    set responsiveStates(v) {
        if (this._responsiveStates !== null) {
            this._responsiveStates._setSyncTarget(null);
            this._responsiveStates = null;
        }
        let coll = new IgrResponsiveStatesCollection();
        this._responsiveStates = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ResponsiveState.$type);
        let innerColl = this.i.en;
        if (!innerColl) {
            innerColl = new ResponsiveStatesCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._responsiveStates._setSyncTarget(syncColl);
    }
    /**
     * Gets the region of the grid that is visible.
    */
    get actualVisibleRegion() {
        return fromRect(this.i.vp);
    }
    /**
     * Gets the current sort that is applied to the grid. Collection can be updated to modify the sort for the grid. Once sort descriptions are in this collection, the grid will no longer listen for changes on their properties.
    */
    get sortDescriptions() {
        if (this.i.b4 == null) {
            return null;
        }
        if (!this.i.b4.externalObject) {
            let e = new IgrColumnSortDescriptionCollection();
            e._implementation = this.i.b4;
            this.i.b4.externalObject = e;
        }
        return this.i.b4.externalObject;
    }
    /**
     * Gets the current grouping that is applied to the grid. Collection can be updated to modify the grouping for the grid. Once grouping descriptions are in this collection, the grid will no longer listen for changes on their properties.
    */
    get groupDescriptions() {
        if (this.i.a7 == null) {
            return null;
        }
        if (!this.i.a7.externalObject) {
            let e = new IgrColumnGroupDescriptionCollection();
            e._implementation = this.i.a7;
            this.i.a7.externalObject = e;
        }
        return this.i.a7.externalObject;
    }
    /**
     * Gets the current filter that is applied to the grid. Collection can be updated to modify the filter for the grid. Once filter expresisons are in this collection, the grid will no longer listen for changes on their properties.
    */
    get filterExpressions() {
        if (this.i.v == null) {
            return null;
        }
        if (!this.i.v.externalObject) {
            let e = new IgrFilterExpressionCollection();
            e._implementation = this.i.v;
            this.i.v.externalObject = e;
        }
        return this.i.v.externalObject;
    }
    /**
     * Gets the current summaries that are applied to the grid.
    */
    get summaryDescriptions() {
        if (this.i.b7 == null) {
            return null;
        }
        if (!this.i.b7.externalObject) {
            let e = new IgrColumnSummaryDescriptionCollection();
            e._implementation = this.i.b7;
            this.i.b7.externalObject = e;
        }
        return this.i.b7.externalObject;
    }
    /**
     * Gets or sets the scope which summaries are calculated for.
    */
    get summaryScope() {
        return this.i.t;
    }
    set summaryScope(v) {
        this.i.t = ensureEnum(DataSourceSummaryScope_$type, v);
    }
    /**
     * Gets or sets whether group headers are collapsable.
    */
    get isGroupCollapsable() {
        return this.i.hs;
    }
    set isGroupCollapsable(v) {
        this.i.hs = ensureBool(v);
    }
    /**
     * Gets or sets how group headers are displayed when there are multiple groups defined in the grid.
    */
    get groupHeaderDisplayMode() {
        return this.i.r;
    }
    set groupHeaderDisplayMode(v) {
        this.i.r = ensureEnum(DataSourceSectionHeaderDisplayMode_$type, v);
    }
    /**
     * Gets or sets whether groups are expanded or collapsed by default.
    */
    get isGroupExpandedDefault() {
        return this.i.ht;
    }
    set isGroupExpandedDefault(v) {
        this.i.ht = ensureBool(v);
    }
    /**
     * Gets or sets the display mode summaries will use inside groups.
    */
    get groupSummaryDisplayMode() {
        return this.i.dy;
    }
    set groupSummaryDisplayMode(v) {
        this.i.dy = ensureEnum(GroupSummaryDisplayMode_$type, v);
    }
    /**
     * Gets or sets whether to automatically accept edits or require explicit acceptance or rejections of edits
     * when handling the CellValueChanging or DataCommitting events.
     * When True, nothing is required on the part of the developer in order for edits to be accepted. In
     * order to validate and reject a user cell edit you must explicitly handle the CellValueChanging event
     * and call the RejectEdit method using the edit ID provided by the event. In order to reject a whole
     * commit you need to handle the DataComitting event and explicitly call the RejectCommit method using
     * the commit ID provided by the event.
     * When False, cell edits are not immediately accepted until you explicitly call the AcceptEdit method
     * using the edit ID provided by the CellValueChanging event. If you do not handle this event then edits
     * will be auto accepted.
    */
    get autoAcceptEdits() {
        return this.i.g2;
    }
    set autoAcceptEdits(v) {
        this.i.g2 = ensureBool(v);
    }
    /**
     * Sets or gets the user provided primary key to assume for the data. Certain functionality of the grid requires a way to uniquely identify items in order to work correctly.
     * If a primary key cannot be inferred from the data source, you may need to provide one here.
    */
    get primaryKey() {
        return this.i.l;
    }
    set primaryKey(v) {
        this.i.l = v;
    }
    /**
     * Gets either the inferred primary key from the data source, or the user provided primary key, if present. Represents the actual primary key that the grid will use in operations that require it.
    */
    get actualPrimaryKey() {
        return this.i.e;
    }
    set actualPrimaryKey(v) {
        this.i.e = v;
    }
    get actualColumns() {
        if (this._actualColumns === null) {
            let coll = new IgrGridColumnCollection();
            let innerColl = this.i.actualColumns;
            if (!innerColl) {
                innerColl = new GridColumnCollection_internal();
            }
            this._actualColumns = coll._fromInner(innerColl);
        }
        return this._actualColumns;
    }
    set actualColumns(v) {
        if (this._actualColumns !== null) {
            this._actualColumns._setSyncTarget(null);
            this._actualColumns = null;
        }
        let coll = new IgrGridColumnCollection();
        this._actualColumns = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(Column.$type);
        let innerColl = this.i.actualColumns;
        if (!innerColl) {
            innerColl = new GridColumnCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._actualColumns._setSyncTarget(syncColl);
    }
    /**
     * Sets or gets whether the grid will react to sort changes.
    */
    get reactsToSortChanges() {
        return this.i.io;
    }
    set reactsToSortChanges(v) {
        this.i.io = ensureBool(v);
    }
    /**
     * Sets or gets whether the grid will react to group changes.
    */
    get reactsToGroupChanges() {
        return this.i.im;
    }
    set reactsToGroupChanges(v) {
        this.i.im = ensureBool(v);
    }
    /**
     * Sets or gets whether the grid will react to filter changes.
    */
    get reactsToFilterChanges() {
        return this.i.il;
    }
    set reactsToFilterChanges(v) {
        this.i.il = ensureBool(v);
    }
    /**
     * Gets whether an undo can be performed.
    */
    get canUndo() {
        return this.i.g9;
    }
    /**
     * Gets whether a redo can be performed.
    */
    get canRedo() {
        return this.i.g8;
    }
    /**
     * Gets whether a commit can be performed. False if there are any errors present
     * on any pending transactions.
    */
    get canCommit() {
        return this.i.g5;
    }
    findByName(name) {
        if (this.sectionHeader && this.sectionHeader.name && this.sectionHeader.name == name) {
            return this.sectionHeader;
        }
        if (this.summaryRowRoot && this.summaryRowRoot.name && this.summaryRowRoot.name == name) {
            return this.summaryRowRoot;
        }
        if (this.summaryRowSection && this.summaryRowSection.name && this.summaryRowSection.name == name) {
            return this.summaryRowSection;
        }
        if (this.rowSeparator && this.rowSeparator.name && this.rowSeparator.name == name) {
            return this.rowSeparator;
        }
        if (this.headerRowSeparator && this.headerRowSeparator.name && this.headerRowSeparator.name == name) {
            return this.headerRowSeparator;
        }
        if (this.headerSeparator && this.headerSeparator.name && this.headerSeparator.name == name) {
            return this.headerSeparator;
        }
        if (this.columnResizingSeparator && this.columnResizingSeparator.name && this.columnResizingSeparator.name == name) {
            return this.columnResizingSeparator;
        }
        if (this.columnMovingSeparator && this.columnMovingSeparator.name && this.columnMovingSeparator.name == name) {
            return this.columnMovingSeparator;
        }
        if (this.pinnedAreaSeparator && this.pinnedAreaSeparator.name && this.pinnedAreaSeparator.name == name) {
            return this.pinnedAreaSeparator;
        }
        if (this.animationSettings && this.animationSettings.name && this.animationSettings.name == name) {
            return this.animationSettings;
        }
        if (this.selectedKeys != null && this.selectedKeys.findByName && this.selectedKeys.findByName(name)) {
            return this.selectedKeys.findByName(name);
        }
        if (this.selectedCells != null && this.selectedCells.findByName && this.selectedCells.findByName(name)) {
            return this.selectedCells.findByName(name);
        }
        if (this.selectedCellRanges != null && this.selectedCellRanges.findByName && this.selectedCellRanges.findByName(name)) {
            return this.selectedCellRanges.findByName(name);
        }
        if (this.pinnedKeys != null && this.pinnedKeys.findByName && this.pinnedKeys.findByName(name)) {
            return this.pinnedKeys.findByName(name);
        }
        if (this.activeCell && this.activeCell.name && this.activeCell.name == name) {
            return this.activeCell;
        }
        if (this.responsiveStates != null && this.responsiveStates.findByName && this.responsiveStates.findByName(name)) {
            return this.responsiveStates.findByName(name);
        }
        if (this.sortDescriptions != null && this.sortDescriptions.findByName && this.sortDescriptions.findByName(name)) {
            return this.sortDescriptions.findByName(name);
        }
        if (this.groupDescriptions != null && this.groupDescriptions.findByName && this.groupDescriptions.findByName(name)) {
            return this.groupDescriptions.findByName(name);
        }
        if (this.filterExpressions != null && this.filterExpressions.findByName && this.filterExpressions.findByName(name)) {
            return this.filterExpressions.findByName(name);
        }
        if (this.summaryDescriptions != null && this.summaryDescriptions.findByName && this.summaryDescriptions.findByName(name)) {
            return this.summaryDescriptions.findByName(name);
        }
        if (this.actualColumns != null && this.actualColumns.findByName && this.actualColumns.findByName(name)) {
            return this.actualColumns.findByName(name);
        }
        if (this.columns != null && this.columns.findByName && this.columns.findByName(name)) {
            return this.columns.findByName(name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DataGrid");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this.sectionHeader && this.sectionHeader._styling) {
            this.sectionHeader._styling(container, component, this);
        }
        if (this.summaryRowRoot && this.summaryRowRoot._styling) {
            this.summaryRowRoot._styling(container, component, this);
        }
        if (this.summaryRowSection && this.summaryRowSection._styling) {
            this.summaryRowSection._styling(container, component, this);
        }
        if (this.rowSeparator && this.rowSeparator._styling) {
            this.rowSeparator._styling(container, component, this);
        }
        if (this.headerRowSeparator && this.headerRowSeparator._styling) {
            this.headerRowSeparator._styling(container, component, this);
        }
        if (this.headerSeparator && this.headerSeparator._styling) {
            this.headerSeparator._styling(container, component, this);
        }
        if (this.columnResizingSeparator && this.columnResizingSeparator._styling) {
            this.columnResizingSeparator._styling(container, component, this);
        }
        if (this.columnMovingSeparator && this.columnMovingSeparator._styling) {
            this.columnMovingSeparator._styling(container, component, this);
        }
        if (this.pinnedAreaSeparator && this.pinnedAreaSeparator._styling) {
            this.pinnedAreaSeparator._styling(container, component, this);
        }
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    getHitCell(x, y) {
        let iv = this.i.ap(x, y);
        return (iv == null ? null : iv.externalObject);
    }
    /**
     * Forces a refresh of the grid content.
    
    */
    refresh() {
        this.i.sk();
    }
    /**
     * Makes sure pending work has completed if the grid need to be synchronously examined.
    
    */
    flush() {
        this.i.p4();
    }
    notifyScrollStart() {
        this.i.notifyScrollStart();
    }
    notifyScrollStop() {
        this.i.notifyScrollStop();
    }
    exchangeColumn(newColumn, oldColumn) {
        this.i.p2((newColumn == null ? null : newColumn.i), (oldColumn == null ? null : oldColumn.i));
    }
    pinColumn(column, position) {
        this.i.sd((column == null ? null : column.i), (position == null ? null : position));
    }
    moveColumn(oldIndex, newIndex) {
        this.i.qf(oldIndex, newIndex);
    }
    /**
     * Moves a column to the left, if possible.
    
    * @param columnIndex  * The index of the column to move.
    */
    moveColumnLeft(columnIndex) {
        this.i.qg(columnIndex);
    }
    /**
     * Moves a column to the right, if possible.
    
    * @param columnIndex  * The index of the column to move.
    */
    moveColumnRight(columnIndex) {
        this.i.qh(columnIndex);
    }
    /**
     * Returns true if a column can be moved to the left of it's current position; otherwise false.
    
    * @param columnIndex  * The index of the column.
    */
    canMoveColumnLeft(columnIndex) {
        let iv = this.i.g6(columnIndex);
        return (iv);
    }
    /**
     * Returns true if a column can be moved to the right of it's current position; otherwise false.
    
    * @param columnIndex  * The index of the column.
    */
    canMoveColumnRight(columnIndex) {
        let iv = this.i.g7(columnIndex);
        return (iv);
    }
    /**
     * Exports visual information about the current state of the grid.
    
    */
    exportVisualModel() {
        let iv = this.i.lp();
        return (iv);
    }
    /**
     * Returns a serialized copy of the exported visual model
    
    */
    exportSerializedVisualModel() {
        let iv = this.i.nb();
        return (iv);
    }
    /**
     * Scrolls the grid to given row, by index
    
    * @param rowNumber  * The row index to scroll to.
    */
    scrollToRowByIndex(rowNumber) {
        this.i.s2(rowNumber);
    }
    /**
     * Scrolls the grid so that a row is the last visible, by index.
    
    * @param rowNumber  * The row index to scroll to.
    */
    scrollToLastRowByIndex(rowNumber) {
        this.i.s1(rowNumber);
    }
    /**
     * Scrolls to an item, if found.
    
    * @param item  * The item to scroll to.
    */
    scrollToItem(item) {
        let iv = this.i.it(item);
        return (iv);
    }
    scrollToPrimaryKey(key) {
        let iv = this.i.iu(key);
        return (iv);
    }
    /**
     * Scrolls the grid to given column, by index
    
    * @param columnNumber  * The column number to scroll to.
    */
    scrollToColumnByIndex(columnNumber) {
        this.i.sz(columnNumber);
    }
    /**
     * Gets the last visible index in the grid.
    
    */
    getLastVisibleIndex() {
        let iv = this.i.k2();
        return (iv);
    }
    /**
     * Gets the first visible index in the grid.
    
    */
    getFirstVisibleIndex() {
        let iv = this.i.ky();
        return (iv);
    }
    /**
     * Invalidates the bound data for the rows currently visible.
    
    */
    invalidateVisibleRows() {
        this.i.qe();
    }
    /**
     * Manually set the active responsive state of the grid.
    
    * @param name
    */
    setActiveResponsiveState(name) {
        this.i.s7(name);
    }
    notifySetItem(index, oldItem, newItem) {
        this.i.qp(index, oldItem, newItem);
    }
    /**
     * Manually notifies the grid's data source that the data it has bound to has been cleared and needs to be re-examined.
     * This should not be called if the data that the grid is bound to is already observable.
    
    */
    notifyClearItems() {
        this.i.qj();
    }
    notifyInsertItem(index, newItem) {
        this.i.ql(index, newItem);
    }
    notifyRemoveItem(index, oldItem) {
        this.i.qm(index, oldItem);
    }
    /**
     * Returns the data index of an item within the bound data source.
    
    * @param item  * The item from which to get the index.
    */
    dataIndexOfItem(item) {
        let iv = this.i.kr(item);
        return (iv);
    }
    dataIndexOfPrimaryKey(key) {
        let iv = this.i.ks(key);
        return (iv);
    }
    /**
     * Resolves the value of a specific cell.
    
    * @param cellKey  * The cell to resolve.
    */
    resolveCellValue(cellKey) {
        let iv = this.i.ls((cellKey == null ? null : cellKey.i));
        return (iv);
    }
    resolveCellValueFromPosition(row, column) {
        let iv = this.i.lt(row, column);
        return (iv);
    }
    /**
     * Gets the column that appears at the index specified. This is not the columns actual index in the
     * column's collection but the index for how it appears visually in the grid.
    
    * @param index  * The rendered index of the column.
    */
    getColumnAtRenderedIndex(index) {
        let iv = this.i.az(index);
        return (iv == null ? null : iv.externalObject);
    }
    /**
     * Gets the summary results for root level.
    
    */
    getRootSummaryResults() {
        let iv = this.i.j();
        return (iv);
    }
    /**
     * Gets the summary results for a specific section.
    
    */
    getSectionSummaryResults(sectionIndex) {
        let iv = this.i.k(sectionIndex);
        return (iv);
    }
    /**
     * Commits any edits that may exist in the datasource.
    
    */
    commitEdits() {
        this.i.px();
    }
    /**
     * Cancels any edits that may exist in the datasource.
    
    */
    cancelEdits() {
        this.i.pp();
    }
    /**
     * Accepts a specific commit to the datasource.
    
    * @param commitID  * The ID of the commit provided by the Committing event.
    */
    acceptCommit(commitID) {
        this.i.pi(commitID);
    }
    /**
     * Rejects a specific commit.
    
    * @param commitID  * The ID of the commit provided by the Committing event.
    */
    rejectCommit(commitID) {
        this.i.sn(commitID);
    }
    /**
     * Undo the last edit.
    
    */
    undo() {
        this.i.tf();
    }
    /**
     * Redo the last edit.
    
    */
    redo() {
        this.i.sj();
    }
    updatePropertyAtKey(key, propertyPath, value) {
        this.i.tk(key, propertyPath, value);
    }
    removeItemByKey(key) {
        this.i.ss(key);
    }
    /**
     * Removes an item by its instance.
    
    * @param item  * The item instance to remove.
    */
    removeItem(item) {
        this.i.sr(item);
    }
    /**
     * Accept a pending edit turning it into a real edit.
    
    * @param editID  * The ID of the edit. Provided by the CellValueChanging event.
    */
    acceptEdit(editID) {
        this.i.pj(editID);
    }
    /**
     * Reject a pending edit.
    
    * @param editID  * The ID of the edit. Provided by the CellValueChanging event.
    */
    rejectEdit(editID) {
        this.i.so(editID);
    }
    setEditError(editID, errorMessage) {
        this.i.s9(editID, errorMessage);
    }
    get filterExpressionsChanging() {
        return this._filterExpressionsChanging;
    }
    set filterExpressionsChanging(ev) {
        if (this._filterExpressionsChanging_wrapped !== null) {
            this.i.filterExpressionsChanging = delegateRemove(this.i.filterExpressionsChanging, this._filterExpressionsChanging_wrapped);
            this._filterExpressionsChanging_wrapped = null;
            this._filterExpressionsChanging = null;
        }
        this._filterExpressionsChanging = ev;
        this._filterExpressionsChanging_wrapped = (o, e) => {
            let outerArgs = new IgrGridFilterExpressionsEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFilterExpressionsChanging) {
                this.beforeFilterExpressionsChanging(this, outerArgs);
            }
            if (this._filterExpressionsChanging) {
                this._filterExpressionsChanging(this, outerArgs);
            }
        };
        this.i.filterExpressionsChanging = delegateCombine(this.i.filterExpressionsChanging, this._filterExpressionsChanging_wrapped);
    }
    get filterExpressionsChanged() {
        return this._filterExpressionsChanged;
    }
    set filterExpressionsChanged(ev) {
        if (this._filterExpressionsChanged_wrapped !== null) {
            this.i.filterExpressionsChanged = delegateRemove(this.i.filterExpressionsChanged, this._filterExpressionsChanged_wrapped);
            this._filterExpressionsChanged_wrapped = null;
            this._filterExpressionsChanged = null;
        }
        this._filterExpressionsChanged = ev;
        this._filterExpressionsChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridFilterExpressionsEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFilterExpressionsChanged) {
                this.beforeFilterExpressionsChanged(this, outerArgs);
            }
            if (this._filterExpressionsChanged) {
                this._filterExpressionsChanged(this, outerArgs);
            }
        };
        this.i.filterExpressionsChanged = delegateCombine(this.i.filterExpressionsChanged, this._filterExpressionsChanged_wrapped);
    }
    /**
     * Previews that a pointer is down on a cell.
    */
    get cellPreviewPointerDown() {
        return this._cellPreviewPointerDown;
    }
    set cellPreviewPointerDown(ev) {
        if (this._cellPreviewPointerDown_wrapped !== null) {
            this.i.cellPreviewPointerDown = delegateRemove(this.i.cellPreviewPointerDown, this._cellPreviewPointerDown_wrapped);
            this._cellPreviewPointerDown_wrapped = null;
            this._cellPreviewPointerDown = null;
        }
        this._cellPreviewPointerDown = ev;
        this._cellPreviewPointerDown_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellPreviewPointerDown) {
                this.beforeCellPreviewPointerDown(this, outerArgs);
            }
            if (this._cellPreviewPointerDown) {
                this._cellPreviewPointerDown(this, outerArgs);
            }
        };
        this.i.cellPreviewPointerDown = delegateCombine(this.i.cellPreviewPointerDown, this._cellPreviewPointerDown_wrapped);
    }
    /**
     * Previews that a pointer is up on a cell.
    */
    get cellPreviewPointerUp() {
        return this._cellPreviewPointerUp;
    }
    set cellPreviewPointerUp(ev) {
        if (this._cellPreviewPointerUp_wrapped !== null) {
            this.i.cellPreviewPointerUp = delegateRemove(this.i.cellPreviewPointerUp, this._cellPreviewPointerUp_wrapped);
            this._cellPreviewPointerUp_wrapped = null;
            this._cellPreviewPointerUp = null;
        }
        this._cellPreviewPointerUp = ev;
        this._cellPreviewPointerUp_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellPreviewPointerUp) {
                this.beforeCellPreviewPointerUp(this, outerArgs);
            }
            if (this._cellPreviewPointerUp) {
                this._cellPreviewPointerUp(this, outerArgs);
            }
        };
        this.i.cellPreviewPointerUp = delegateCombine(this.i.cellPreviewPointerUp, this._cellPreviewPointerUp_wrapped);
    }
    /**
     * Indicates a pointer is down on a cell.
    */
    get cellPointerDown() {
        return this._cellPointerDown;
    }
    set cellPointerDown(ev) {
        if (this._cellPointerDown_wrapped !== null) {
            this.i.cellPointerDown = delegateRemove(this.i.cellPointerDown, this._cellPointerDown_wrapped);
            this._cellPointerDown_wrapped = null;
            this._cellPointerDown = null;
        }
        this._cellPointerDown = ev;
        this._cellPointerDown_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellPointerDown) {
                this.beforeCellPointerDown(this, outerArgs);
            }
            if (this._cellPointerDown) {
                this._cellPointerDown(this, outerArgs);
            }
        };
        this.i.cellPointerDown = delegateCombine(this.i.cellPointerDown, this._cellPointerDown_wrapped);
    }
    /**
     * Indicates a pointer is up on a cell.
    */
    get cellPointerUp() {
        return this._cellPointerUp;
    }
    set cellPointerUp(ev) {
        if (this._cellPointerUp_wrapped !== null) {
            this.i.cellPointerUp = delegateRemove(this.i.cellPointerUp, this._cellPointerUp_wrapped);
            this._cellPointerUp_wrapped = null;
            this._cellPointerUp = null;
        }
        this._cellPointerUp = ev;
        this._cellPointerUp_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellPointerUp) {
                this.beforeCellPointerUp(this, outerArgs);
            }
            if (this._cellPointerUp) {
                this._cellPointerUp(this, outerArgs);
            }
        };
        this.i.cellPointerUp = delegateCombine(this.i.cellPointerUp, this._cellPointerUp_wrapped);
    }
    /**
     * Called when a cell is clicked.
    */
    get cellClicked() {
        return this._cellClicked;
    }
    set cellClicked(ev) {
        if (this._cellClicked_wrapped !== null) {
            this.i.cellClicked = delegateRemove(this.i.cellClicked, this._cellClicked_wrapped);
            this._cellClicked_wrapped = null;
            this._cellClicked = null;
        }
        this._cellClicked = ev;
        this._cellClicked_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellClicked) {
                this.beforeCellClicked(this, outerArgs);
            }
            if (this._cellClicked) {
                this._cellClicked(this, outerArgs);
            }
        };
        this.i.cellClicked = delegateCombine(this.i.cellClicked, this._cellClicked_wrapped);
    }
    /**
     * Called when sorting has changed.
    */
    get sortDescriptionsChanged() {
        return this._sortDescriptionsChanged;
    }
    set sortDescriptionsChanged(ev) {
        if (this._sortDescriptionsChanged_wrapped !== null) {
            this.i.sortDescriptionsChanged = delegateRemove(this.i.sortDescriptionsChanged, this._sortDescriptionsChanged_wrapped);
            this._sortDescriptionsChanged_wrapped = null;
            this._sortDescriptionsChanged = null;
        }
        this._sortDescriptionsChanged = ev;
        this._sortDescriptionsChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridSortDescriptionsChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSortDescriptionsChanged) {
                this.beforeSortDescriptionsChanged(this, outerArgs);
            }
            if (this._sortDescriptionsChanged) {
                this._sortDescriptionsChanged(this, outerArgs);
            }
        };
        this.i.sortDescriptionsChanged = delegateCombine(this.i.sortDescriptionsChanged, this._sortDescriptionsChanged_wrapped);
    }
    /**
     * Called when grouping has changed.
    */
    get groupDescriptionsChanged() {
        return this._groupDescriptionsChanged;
    }
    set groupDescriptionsChanged(ev) {
        if (this._groupDescriptionsChanged_wrapped !== null) {
            this.i.groupDescriptionsChanged = delegateRemove(this.i.groupDescriptionsChanged, this._groupDescriptionsChanged_wrapped);
            this._groupDescriptionsChanged_wrapped = null;
            this._groupDescriptionsChanged = null;
        }
        this._groupDescriptionsChanged = ev;
        this._groupDescriptionsChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridGroupDescriptionsChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeGroupDescriptionsChanged) {
                this.beforeGroupDescriptionsChanged(this, outerArgs);
            }
            if (this._groupDescriptionsChanged) {
                this._groupDescriptionsChanged(this, outerArgs);
            }
        };
        this.i.groupDescriptionsChanged = delegateCombine(this.i.groupDescriptionsChanged, this._groupDescriptionsChanged_wrapped);
    }
    /**
     * Called when a column is hidden or unhidden.
    */
    get columnHiddenChanged() {
        return this._columnHiddenChanged;
    }
    set columnHiddenChanged(ev) {
        if (this._columnHiddenChanged_wrapped !== null) {
            this.i.columnHiddenChanged = delegateRemove(this.i.columnHiddenChanged, this._columnHiddenChanged_wrapped);
            this._columnHiddenChanged_wrapped = null;
            this._columnHiddenChanged = null;
        }
        this._columnHiddenChanged = ev;
        this._columnHiddenChanged_wrapped = (o, e) => {
            let outerArgs = new IgrColumnHiddenChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeColumnHiddenChanged) {
                this.beforeColumnHiddenChanged(this, outerArgs);
            }
            if (this._columnHiddenChanged) {
                this._columnHiddenChanged(this, outerArgs);
            }
        };
        this.i.columnHiddenChanged = delegateCombine(this.i.columnHiddenChanged, this._columnHiddenChanged_wrapped);
    }
    /**
     * Called when a column is pinned or unpinned.
    */
    get columnPinnedChanged() {
        return this._columnPinnedChanged;
    }
    set columnPinnedChanged(ev) {
        if (this._columnPinnedChanged_wrapped !== null) {
            this.i.columnPinnedChanged = delegateRemove(this.i.columnPinnedChanged, this._columnPinnedChanged_wrapped);
            this._columnPinnedChanged_wrapped = null;
            this._columnPinnedChanged = null;
        }
        this._columnPinnedChanged = ev;
        this._columnPinnedChanged_wrapped = (o, e) => {
            let outerArgs = new IgrColumnPinnedChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeColumnPinnedChanged) {
                this.beforeColumnPinnedChanged(this, outerArgs);
            }
            if (this._columnPinnedChanged) {
                this._columnPinnedChanged(this, outerArgs);
            }
        };
        this.i.columnPinnedChanged = delegateCombine(this.i.columnPinnedChanged, this._columnPinnedChanged_wrapped);
    }
    /**
     * Called when a cell has been edited.
    */
    get cellValueChanging() {
        return this._cellValueChanging;
    }
    set cellValueChanging(ev) {
        if (this._cellValueChanging_wrapped !== null) {
            this.i.cellValueChanging = delegateRemove(this.i.cellValueChanging, this._cellValueChanging_wrapped);
            this._cellValueChanging_wrapped = null;
            this._cellValueChanging = null;
        }
        this._cellValueChanging = ev;
        this._cellValueChanging_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellValueChangingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellValueChanging) {
                this.beforeCellValueChanging(this, outerArgs);
            }
            if (this._cellValueChanging) {
                this._cellValueChanging(this, outerArgs);
            }
        };
        this.i.cellValueChanging = delegateCombine(this.i.cellValueChanging, this._cellValueChanging_wrapped);
    }
    /**
     * Called when edits have been committed to the datasource.
    */
    get dataCommitted() {
        return this._dataCommitted;
    }
    set dataCommitted(ev) {
        if (this._dataCommitted_wrapped !== null) {
            this.i.dataCommitted = delegateRemove(this.i.dataCommitted, this._dataCommitted_wrapped);
            this._dataCommitted_wrapped = null;
            this._dataCommitted = null;
        }
        this._dataCommitted = ev;
        this._dataCommitted_wrapped = (o, e) => {
            let outerArgs = new IgrGridDataCommittedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeDataCommitted) {
                this.beforeDataCommitted(this, outerArgs);
            }
            if (this._dataCommitted) {
                this._dataCommitted(this, outerArgs);
            }
        };
        this.i.dataCommitted = delegateCombine(this.i.dataCommitted, this._dataCommitted_wrapped);
    }
    /**
     * Called when edits are about to be committed to the datasource.
    */
    get dataCommitting() {
        return this._dataCommitting;
    }
    set dataCommitting(ev) {
        if (this._dataCommitting_wrapped !== null) {
            this.i.dataCommitting = delegateRemove(this.i.dataCommitting, this._dataCommitting_wrapped);
            this._dataCommitting_wrapped = null;
            this._dataCommitting = null;
        }
        this._dataCommitting = ev;
        this._dataCommitting_wrapped = (o, e) => {
            let outerArgs = new IgrGridDataCommittingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeDataCommitting) {
                this.beforeDataCommitting(this, outerArgs);
            }
            if (this._dataCommitting) {
                this._dataCommitting(this, outerArgs);
            }
        };
        this.i.dataCommitting = delegateCombine(this.i.dataCommitting, this._dataCommitting_wrapped);
    }
    /**
     * Called when the grids size has changed.
    */
    get sizeChanged() {
        return this._sizeChanged;
    }
    set sizeChanged(ev) {
        if (this._sizeChanged_wrapped !== null) {
            this.i.sizeChanged = delegateRemove(this.i.sizeChanged, this._sizeChanged_wrapped);
            this._sizeChanged_wrapped = null;
            this._sizeChanged = null;
        }
        this._sizeChanged = ev;
        this._sizeChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridSizeChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSizeChanged) {
                this.beforeSizeChanged(this, outerArgs);
            }
            if (this._sizeChanged) {
                this._sizeChanged(this, outerArgs);
            }
        };
        this.i.sizeChanged = delegateCombine(this.i.sizeChanged, this._sizeChanged_wrapped);
    }
    get actualColumnsChanged() {
        return this._actualColumnsChanged;
    }
    set actualColumnsChanged(ev) {
        if (this._actualColumnsChanged_wrapped !== null) {
            this.i.actualColumnsChanged = delegateRemove(this.i.actualColumnsChanged, this._actualColumnsChanged_wrapped);
            this._actualColumnsChanged_wrapped = null;
            this._actualColumnsChanged = null;
        }
        this._actualColumnsChanged = ev;
        this._actualColumnsChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridColumnsChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeActualColumnsChanged) {
                this.beforeActualColumnsChanged(this, outerArgs);
            }
            if (this._actualColumnsChanged) {
                this._actualColumnsChanged(this, outerArgs);
            }
        };
        this.i.actualColumnsChanged = delegateCombine(this.i.actualColumnsChanged, this._actualColumnsChanged_wrapped);
    }
    /**
     * Called when the columns are autogenerated.
    */
    get columnsAutoGenerated() {
        return this._columnsAutoGenerated;
    }
    set columnsAutoGenerated(ev) {
        if (this._columnsAutoGenerated_wrapped !== null) {
            this.i.columnsAutoGenerated = delegateRemove(this.i.columnsAutoGenerated, this._columnsAutoGenerated_wrapped);
            this._columnsAutoGenerated_wrapped = null;
            this._columnsAutoGenerated = null;
        }
        this._columnsAutoGenerated = ev;
        this._columnsAutoGenerated_wrapped = (o, e) => {
            let outerArgs = new IgrGridColumnsAutoGeneratedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeColumnsAutoGenerated) {
                this.beforeColumnsAutoGenerated(this, outerArgs);
            }
            if (this._columnsAutoGenerated) {
                this._columnsAutoGenerated(this, outerArgs);
            }
        };
        this.i.columnsAutoGenerated = delegateCombine(this.i.columnsAutoGenerated, this._columnsAutoGenerated_wrapped);
    }
    /**
     * Called when the selected items change.
    */
    get selectedItemsChanged() {
        return this._selectedItemsChanged;
    }
    set selectedItemsChanged(ev) {
        if (this._selectedItemsChanged_wrapped !== null) {
            this.i.selectedItemsChanged = delegateRemove(this.i.selectedItemsChanged, this._selectedItemsChanged_wrapped);
            this._selectedItemsChanged_wrapped = null;
            this._selectedItemsChanged = null;
        }
        this._selectedItemsChanged = ev;
        this._selectedItemsChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridSelectedItemsChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedItemsChanged) {
                this.beforeSelectedItemsChanged(this, outerArgs);
            }
            if (this._selectedItemsChanged) {
                this._selectedItemsChanged(this, outerArgs);
            }
        };
        this.i.selectedItemsChanged = delegateCombine(this.i.selectedItemsChanged, this._selectedItemsChanged_wrapped);
    }
    /**
     * Called when the selected keys change.
    */
    get selectedKeysChanged() {
        return this._selectedKeysChanged;
    }
    set selectedKeysChanged(ev) {
        if (this._selectedKeysChanged_wrapped !== null) {
            this.i.selectedKeysChanged = delegateRemove(this.i.selectedKeysChanged, this._selectedKeysChanged_wrapped);
            this._selectedKeysChanged_wrapped = null;
            this._selectedKeysChanged = null;
        }
        this._selectedKeysChanged = ev;
        this._selectedKeysChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridSelectedKeysChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedKeysChanged) {
                this.beforeSelectedKeysChanged(this, outerArgs);
            }
            if (this._selectedKeysChanged) {
                this._selectedKeysChanged(this, outerArgs);
            }
        };
        this.i.selectedKeysChanged = delegateCombine(this.i.selectedKeysChanged, this._selectedKeysChanged_wrapped);
    }
    /**
     * Called when the selected cells change.
    */
    get selectedCellsChanged() {
        return this._selectedCellsChanged;
    }
    set selectedCellsChanged(ev) {
        if (this._selectedCellsChanged_wrapped !== null) {
            this.i.selectedCellsChanged = delegateRemove(this.i.selectedCellsChanged, this._selectedCellsChanged_wrapped);
            this._selectedCellsChanged_wrapped = null;
            this._selectedCellsChanged = null;
        }
        this._selectedCellsChanged = ev;
        this._selectedCellsChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridSelectedCellsChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedCellsChanged) {
                this.beforeSelectedCellsChanged(this, outerArgs);
            }
            if (this._selectedCellsChanged) {
                this._selectedCellsChanged(this, outerArgs);
            }
        };
        this.i.selectedCellsChanged = delegateCombine(this.i.selectedCellsChanged, this._selectedCellsChanged_wrapped);
    }
    /**
     * Called when the active cell changes.
    */
    get activeCellChanged() {
        return this._activeCellChanged;
    }
    set activeCellChanged(ev) {
        if (this._activeCellChanged_wrapped !== null) {
            this.i.activeCellChanged = delegateRemove(this.i.activeCellChanged, this._activeCellChanged_wrapped);
            this._activeCellChanged_wrapped = null;
            this._activeCellChanged = null;
        }
        this._activeCellChanged = ev;
        this._activeCellChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridActiveCellChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeActiveCellChanged) {
                this.beforeActiveCellChanged(this, outerArgs);
            }
            if (this._activeCellChanged) {
                this._activeCellChanged(this, outerArgs);
            }
        };
        this.i.activeCellChanged = delegateCombine(this.i.activeCellChanged, this._activeCellChanged_wrapped);
    }
    /**
     * Called when the selected cell ranges changed.
    */
    get selectedCellRangesChanged() {
        return this._selectedCellRangesChanged;
    }
    set selectedCellRangesChanged(ev) {
        if (this._selectedCellRangesChanged_wrapped !== null) {
            this.i.selectedCellRangesChanged = delegateRemove(this.i.selectedCellRangesChanged, this._selectedCellRangesChanged_wrapped);
            this._selectedCellRangesChanged_wrapped = null;
            this._selectedCellRangesChanged = null;
        }
        this._selectedCellRangesChanged = ev;
        this._selectedCellRangesChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridSelectedCellRangesChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedCellRangesChanged) {
                this.beforeSelectedCellRangesChanged(this, outerArgs);
            }
            if (this._selectedCellRangesChanged) {
                this._selectedCellRangesChanged(this, outerArgs);
            }
        };
        this.i.selectedCellRangesChanged = delegateCombine(this.i.selectedCellRangesChanged, this._selectedCellRangesChanged_wrapped);
    }
    /**
     * Called when a column's Width property has changed.
    */
    get columnWidthChanged() {
        return this._columnWidthChanged;
    }
    set columnWidthChanged(ev) {
        if (this._columnWidthChanged_wrapped !== null) {
            this.i.columnWidthChanged = delegateRemove(this.i.columnWidthChanged, this._columnWidthChanged_wrapped);
            this._columnWidthChanged_wrapped = null;
            this._columnWidthChanged = null;
        }
        this._columnWidthChanged = ev;
        this._columnWidthChanged_wrapped = (o, e) => {
            let outerArgs = new IgrGridColumnWidthChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeColumnWidthChanged) {
                this.beforeColumnWidthChanged(this, outerArgs);
            }
            if (this._columnWidthChanged) {
                this._columnWidthChanged(this, outerArgs);
            }
        };
        this.i.columnWidthChanged = delegateCombine(this.i.columnWidthChanged, this._columnWidthChanged_wrapped);
    }
    get cellEditStarted() {
        return this._cellEditStarted;
    }
    set cellEditStarted(ev) {
        if (this._cellEditStarted_wrapped !== null) {
            this.i.cellEditStarted = delegateRemove(this.i.cellEditStarted, this._cellEditStarted_wrapped);
            this._cellEditStarted_wrapped = null;
            this._cellEditStarted = null;
        }
        this._cellEditStarted = ev;
        this._cellEditStarted_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellEditStartedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellEditStarted) {
                this.beforeCellEditStarted(this, outerArgs);
            }
            if (this._cellEditStarted) {
                this._cellEditStarted(this, outerArgs);
            }
        };
        this.i.cellEditStarted = delegateCombine(this.i.cellEditStarted, this._cellEditStarted_wrapped);
    }
    get cellEditEnded() {
        return this._cellEditEnded;
    }
    set cellEditEnded(ev) {
        if (this._cellEditEnded_wrapped !== null) {
            this.i.cellEditEnded = delegateRemove(this.i.cellEditEnded, this._cellEditEnded_wrapped);
            this._cellEditEnded_wrapped = null;
            this._cellEditEnded = null;
        }
        this._cellEditEnded = ev;
        this._cellEditEnded_wrapped = (o, e) => {
            let outerArgs = new IgrGridCellEditEndedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellEditEnded) {
                this.beforeCellEditEnded(this, outerArgs);
            }
            if (this._cellEditEnded) {
                this._cellEditEnded(this, outerArgs);
            }
        };
        this.i.cellEditEnded = delegateCombine(this.i.cellEditEnded, this._cellEditEnded_wrapped);
    }
    get rowEditStarted() {
        return this._rowEditStarted;
    }
    set rowEditStarted(ev) {
        if (this._rowEditStarted_wrapped !== null) {
            this.i.rowEditStarted = delegateRemove(this.i.rowEditStarted, this._rowEditStarted_wrapped);
            this._rowEditStarted_wrapped = null;
            this._rowEditStarted = null;
        }
        this._rowEditStarted = ev;
        this._rowEditStarted_wrapped = (o, e) => {
            let outerArgs = new IgrGridRowEditStartedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeRowEditStarted) {
                this.beforeRowEditStarted(this, outerArgs);
            }
            if (this._rowEditStarted) {
                this._rowEditStarted(this, outerArgs);
            }
        };
        this.i.rowEditStarted = delegateCombine(this.i.rowEditStarted, this._rowEditStarted_wrapped);
    }
    get rowEditEnded() {
        return this._rowEditEnded;
    }
    set rowEditEnded(ev) {
        if (this._rowEditEnded_wrapped !== null) {
            this.i.rowEditEnded = delegateRemove(this.i.rowEditEnded, this._rowEditEnded_wrapped);
            this._rowEditEnded_wrapped = null;
            this._rowEditEnded = null;
        }
        this._rowEditEnded = ev;
        this._rowEditEnded_wrapped = (o, e) => {
            let outerArgs = new IgrGridRowEditEndedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeRowEditEnded) {
                this.beforeRowEditEnded(this, outerArgs);
            }
            if (this._rowEditEnded) {
                this._rowEditEnded(this, outerArgs);
            }
        };
        this.i.rowEditEnded = delegateCombine(this.i.rowEditEnded, this._rowEditEnded_wrapped);
    }
    get actualPrimaryKeyChange() {
        return this._actualPrimaryKeyChange;
    }
    set actualPrimaryKeyChange(ev) {
        if (this._actualPrimaryKeyChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualPrimaryKeyChange_wrapped);
            this._actualPrimaryKeyChange_wrapped = null;
            this._actualPrimaryKeyChange = null;
        }
        this._actualPrimaryKeyChange = ev;
        this._actualPrimaryKeyChange_wrapped = (o, e) => {
            let ext = this.actualPrimaryKey;
            if (this.beforeActualPrimaryKeyChange) {
                this.beforeActualPrimaryKeyChange(this, ext);
            }
            if (this._actualPrimaryKeyChange) {
                this._actualPrimaryKeyChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualPrimaryKeyChange_wrapped);
    }
}
//# sourceMappingURL=igr-data-grid.js.map
