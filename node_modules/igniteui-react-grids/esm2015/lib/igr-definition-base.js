import * as React from 'react';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { CellContentHorizontalAlignment_$type } from "./CellContentHorizontalAlignment";
import { CellContentVerticalAlignment_$type } from "./CellContentVerticalAlignment";
import { TextCellLineBreakMode_$type } from "./TextCellLineBreakMode";
import { IgrDataBindingEventArgs } from "./igr-data-binding-event-args";
import { IgrCellStyleRequestedEventArgs } from "./igr-cell-style-requested-event-args";
import { getModifiedProps, isValidProp, brushToString, stringToBrush, ensureEnum, initializePropertiesFromCss, NamePatcher, toSpinal } from "igniteui-react-core";
import { FontInfo } from "igniteui-react-core";
import { ColumnPropertyUpdatingAnimationMode } from './ColumnPropertyUpdatingAnimationMode';
import { TypeRegistrar } from "igniteui-react-core";
/**
 * Base class for various definition types for the grid.
*/
export class IgrDefinitionBase extends React.Component {
    constructor(props) {
        super(props);
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._renderer = null;
        this._dataBinding = null;
        this._dataBinding_wrapped = null;
        this._dataBound = null;
        this._dataBound_wrapped = null;
        this._cellStyleKeyRequested = null;
        this._cellStyleKeyRequested_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    createImplementation() {
        return null;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    onImplementationCreated() {
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        this._stylingContainer = container;
        this._stylingParent = component;
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        let grid = component._grid;
        var prev;
        if (grid) {
            prev = grid.columnPropertyUpdatingAnimationMode;
            grid.columnPropertyUpdatingAnimationMode = ColumnPropertyUpdatingAnimationMode.None;
        }
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        let lowerTypeName = typeName.toLowerCase();
        if (lowerTypeName.indexOf("column") >= 0) {
            genericPrefix = "column";
        }
        else if (lowerTypeName.indexOf("sectionheader") >= 0) {
            genericPrefix = "section-header";
        }
        else if (lowerTypeName.indexOf("sectionfooter") >= 0) {
            genericPrefix = "section-footer";
        }
        else if (lowerTypeName.indexOf("rowseparator") >= 0) {
            genericPrefix = "row-separator";
        }
        else if (lowerTypeName.indexOf("summaryrowroot") >= 0) {
            genericPrefix = "summary-row-root";
        }
        else if (lowerTypeName.indexOf("summaryrowsection") >= 0) {
            genericPrefix = "summary-row-section";
        }
        else if (lowerTypeName.indexOf("headerseparator") >= 0) {
            genericPrefix = "header-separator";
        }
        else {
            genericPrefix = "header";
        }
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName == "Grid") {
                parentTypeName = "DataGrid";
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (grid) {
            grid.columnPropertyUpdatingAnimationMode = prev;
        }
        this._inStyling = false;
    }
    _provideRenderer(renderer) {
        this._renderer = renderer;
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
 * Gets or sets the background color to use.
*/
    get background() {
        return brushToString(this.i.d7);
    }
    set background(v) {
        this.i.d7 = stringToBrush(v);
    }
    /**
     * Gets or sets the background color to use.
    */
    get border() {
        return brushToString(this.i.d8);
    }
    set border(v) {
        this.i.d8 = stringToBrush(v);
    }
    /**
     * Gets or sets the background color to use.
    */
    get activationBorder() {
        return brushToString(this.i.dy);
    }
    set activationBorder(v) {
        this.i.dy = stringToBrush(v);
    }
    /**
     * Gets or sets the error border color to use.
    */
    get errorBorder() {
        return brushToString(this.i.d9);
    }
    set errorBorder(v) {
        this.i.d9 = stringToBrush(v);
    }
    /**
     * Gets the actual border color that will be used.
    */
    get actualBorder() {
        return brushToString(this.i.d1);
    }
    set actualBorder(v) {
        this.i.d1 = stringToBrush(v);
    }
    /**
     * Gets or sets the amount of left border to use for the cell content for this column.
    */
    get borderLeftWidth() {
        return this.i.be;
    }
    set borderLeftWidth(v) {
        this.i.be = +v;
    }
    /**
     * Gets or sets the amount of top border to use for the cell content for this column.
    */
    get borderTopWidth() {
        return this.i.bg;
    }
    set borderTopWidth(v) {
        this.i.bg = +v;
    }
    /**
     * Gets or sets the amount of right border to use for the cell content of this column.
    */
    get borderRightWidth() {
        return this.i.bf;
    }
    set borderRightWidth(v) {
        this.i.bf = +v;
    }
    /**
     * Gets or sets the amount of bottom border to use for the cell content of this column.
    */
    get borderBottomWidth() {
        return this.i.bd;
    }
    set borderBottomWidth(v) {
        this.i.bd = +v;
    }
    /**
     * Gets or sets the amount of left activation border to use for the cell content for this column.
    */
    get activationBorderLeftWidth() {
        return this.i.ba;
    }
    set activationBorderLeftWidth(v) {
        this.i.ba = +v;
    }
    /**
     * Gets or sets the amount of top activation border to use for the cell content for this column.
    */
    get activationBorderTopWidth() {
        return this.i.bc;
    }
    set activationBorderTopWidth(v) {
        this.i.bc = +v;
    }
    /**
     * Gets or sets the amount of right activation border to use for the cell content of this column.
    */
    get activationBorderRightWidth() {
        return this.i.bb;
    }
    set activationBorderRightWidth(v) {
        this.i.bb = +v;
    }
    /**
     * Gets or sets the amount of bottom activation border to use for the cell content of this column.
    */
    get activationBorderBottomWidth() {
        return this.i.a9;
    }
    set activationBorderBottomWidth(v) {
        this.i.a9 = +v;
    }
    get errorBorderLeftWidth() {
        return this.i.bi;
    }
    set errorBorderLeftWidth(v) {
        this.i.bi = +v;
    }
    get errorBorderTopWidth() {
        return this.i.bk;
    }
    set errorBorderTopWidth(v) {
        this.i.bk = +v;
    }
    get errorBorderRightWidth() {
        return this.i.bj;
    }
    set errorBorderRightWidth(v) {
        this.i.bj = +v;
    }
    get errorBorderBottomWidth() {
        return this.i.bh;
    }
    set errorBorderBottomWidth(v) {
        this.i.bh = +v;
    }
    /**
     * Gets the actual background color that will be used.
    */
    get actualBackground() {
        return brushToString(this.i.d0);
    }
    set actualBackground(v) {
        this.i.d0 = stringToBrush(v);
    }
    /**
     * Gets the actual background color that will be used.
    */
    get actualActivationBorder() {
        return brushToString(this.i.dz);
    }
    set actualActivationBorder(v) {
        this.i.dz = stringToBrush(v);
    }
    /**
     * Gets the actual error border color that will be used.
    */
    get actualErrorBorder() {
        return brushToString(this.i.d2);
    }
    set actualErrorBorder(v) {
        this.i.d2 = stringToBrush(v);
    }
    /**
     * Gets or sets the background color for content that sticks to the top of the grid.
    */
    get stickyRowBackground() {
        return brushToString(this.i.ej);
    }
    set stickyRowBackground(v) {
        this.i.ej = stringToBrush(v);
    }
    /**
     * Gets the actual background color for content that sticks to the top of the grid.
    */
    get actualStickyRowBackground() {
        return brushToString(this.i.d5);
    }
    set actualStickyRowBackground(v) {
        this.i.d5 = stringToBrush(v);
    }
    /**
     * Gets or sets the background color for cells belonging to rows marked as pinned.
    */
    get pinnedRowBackground() {
        return brushToString(this.i.ei);
    }
    set pinnedRowBackground(v) {
        this.i.ei = stringToBrush(v);
    }
    /**
     * Gets the actual background color for cells belonging to rows marked as pinned.
    */
    get actualPinnedRowBackground() {
        return brushToString(this.i.d4);
    }
    set actualPinnedRowBackground(v) {
        this.i.d4 = stringToBrush(v);
    }
    /**
     * Gets or sets the color for the last row in the sticky row area.
    */
    get lastStickyRowBackground() {
        return brushToString(this.i.eh);
    }
    set lastStickyRowBackground(v) {
        this.i.eh = stringToBrush(v);
    }
    /**
     * Gets the actual color for the last row in the sticky row area.
    */
    get actualLastStickyRowBackground() {
        return brushToString(this.i.d3);
    }
    set actualLastStickyRowBackground(v) {
        this.i.d3 = stringToBrush(v);
    }
    /**
     * Gets or sets the opacity of the content.
    */
    get contentOpacity() {
        return this.i.au;
    }
    set contentOpacity(v) {
        this.i.au = +v;
    }
    /**
     * Gets or sets the horizontal alignment to use for the cell content.
    */
    get horizontalAlignment() {
        return this.i.e;
    }
    set horizontalAlignment(v) {
        this.i.e = ensureEnum(CellContentHorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets the vertical alignment to use for the cell content.
    */
    get verticalAlignment() {
        return this.i.j;
    }
    set verticalAlignment(v) {
        this.i.j = ensureEnum(CellContentVerticalAlignment_$type, v);
    }
    /**
     * Gets or sets the line breaking mode to use if text is present in the cell.
    */
    get lineBreakMode() {
        return this.i.y;
    }
    set lineBreakMode(v) {
        this.i.y = ensureEnum(TextCellLineBreakMode_$type, v);
    }
    /**
     * Gets the actual line break mode which will be used if text is present in the cell.
    */
    get actualLineBreakMode() {
        return this.i.x;
    }
    set actualLineBreakMode(v) {
        this.i.x = ensureEnum(TextCellLineBreakMode_$type, v);
    }
    /**
     * Gets or sets the color to use for displaying text.
    */
    get textColor() {
        return brushToString(this.i.ek);
    }
    set textColor(v) {
        this.i.ek = stringToBrush(v);
    }
    /**
     * Gets the actual color used for displaying text.
    */
    get actualTextColor() {
        return brushToString(this.i.d6);
    }
    set actualTextColor(v) {
        this.i.d6 = stringToBrush(v);
    }
    /**
     * Gets or sets the color to use for displaying text.
    */
    get pinnedRowOpacity() {
        return this.i.aw;
    }
    set pinnedRowOpacity(v) {
        this.i.aw = +v;
    }
    /**
     * Gets or sets the color to use for displaying text.
    */
    get actualPinnedRowOpacity() {
        return this.i.at;
    }
    set actualPinnedRowOpacity(v) {
        this.i.at = +v;
    }
    get textStyle() {
        if (this.i.textStyle == null) {
            return null;
        }
        return this.i.textStyle.fontString;
    }
    set textStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.textStyle = fi;
    }
    findByName(name) {
        return null;
    }
    setNamedValue(valueName, animationType, value) {
        this.i.c6(valueName, (animationType == null ? null : animationType), value);
    }
    /**
     * Returns if this definition has named value.
    
    */
    hasNamedValues() {
        let iv = this.i.ai();
        return (iv);
    }
    /**
     * Returns if this definition has a named value with a given name.
    
    * @param valueName  * The named value name to check for.
    */
    hasNamedValue(valueName) {
        let iv = this.i.ah(valueName);
        return (iv);
    }
    /**
     * Removes the named value from this definition by name.
    
    * @param valueName  * The named value name to remove.
    */
    removeNamedValue(valueName) {
        this.i.c4(valueName);
    }
    /**
     * Gets the value for a named value from this definition.
    
    * @param valueName  * The named value name to check for.
    */
    getNamedValue(valueName) {
        let iv = this.i.bn(valueName);
        return (iv);
    }
    /**
     * Called when a cell is data binding.
    */
    get dataBinding() {
        return this._dataBinding;
    }
    set dataBinding(ev) {
        if (this._dataBinding_wrapped !== null) {
            this.i.dataBinding = delegateRemove(this.i.dataBinding, this._dataBinding_wrapped);
            this._dataBinding_wrapped = null;
            this._dataBinding = null;
        }
        this._dataBinding = ev;
        this._dataBinding_wrapped = (o, e) => {
            let outerArgs = new IgrDataBindingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeDataBinding) {
                this.beforeDataBinding(this, outerArgs);
            }
            if (this._dataBinding) {
                this._dataBinding(this, outerArgs);
            }
        };
        this.i.dataBinding = delegateCombine(this.i.dataBinding, this._dataBinding_wrapped);
    }
    /**
     * Called when a cell has been data bound.
    */
    get dataBound() {
        return this._dataBound;
    }
    set dataBound(ev) {
        if (this._dataBound_wrapped !== null) {
            this.i.dataBound = delegateRemove(this.i.dataBound, this._dataBound_wrapped);
            this._dataBound_wrapped = null;
            this._dataBound = null;
        }
        this._dataBound = ev;
        this._dataBound_wrapped = (o, e) => {
            let outerArgs = new IgrDataBindingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeDataBound) {
                this.beforeDataBound(this, outerArgs);
            }
            if (this._dataBound) {
                this._dataBound(this, outerArgs);
            }
        };
        this.i.dataBound = delegateCombine(this.i.dataBound, this._dataBound_wrapped);
    }
    /**
     * Called when the style key for a cell is needed. Used for recycling the cell.
    */
    get cellStyleKeyRequested() {
        return this._cellStyleKeyRequested;
    }
    set cellStyleKeyRequested(ev) {
        if (this._cellStyleKeyRequested_wrapped !== null) {
            this.i.cellStyleKeyRequested = delegateRemove(this.i.cellStyleKeyRequested, this._cellStyleKeyRequested_wrapped);
            this._cellStyleKeyRequested_wrapped = null;
            this._cellStyleKeyRequested = null;
        }
        this._cellStyleKeyRequested = ev;
        this._cellStyleKeyRequested_wrapped = (o, e) => {
            let outerArgs = new IgrCellStyleRequestedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCellStyleKeyRequested) {
                this.beforeCellStyleKeyRequested(this, outerArgs);
            }
            if (this._cellStyleKeyRequested) {
                this._cellStyleKeyRequested(this, outerArgs);
            }
        };
        this.i.cellStyleKeyRequested = delegateCombine(this.i.cellStyleKeyRequested, this._cellStyleKeyRequested_wrapped);
    }
}
//# sourceMappingURL=igr-definition-base.js.map
