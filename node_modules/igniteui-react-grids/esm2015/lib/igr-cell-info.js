import { CellContentHorizontalAlignment, CellContentHorizontalAlignment_$type } from "./CellContentHorizontalAlignment";
import { CellContentVerticalAlignment_$type } from "./CellContentVerticalAlignment";
import { TextCellLineBreakMode_$type } from "./TextCellLineBreakMode";
import { ColumnSortDirection_$type } from "./ColumnSortDirection";
import { ensureBool, ensureEnum, brushToString, stringToBrush } from "igniteui-react-core";
import { FontInfo } from "igniteui-react-core";
import { delegateCombine, delegateRemove, runOn } from "igniteui-react-core";
import { PinnedPositions_$type } from './PinnedPositions';
/**
 * Represents info about the current cell.
*/
export class IgrCellInfo {
    constructor() {
        this._onChanged = [];
        this._changed = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    createImplementation() {
        return null;
    }
    get i() {
        return this._implementation;
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    onImplementationCreated() {
    }
    addOnChangedListener(listener) {
        if (this._onChanged.length == 0) {
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, runOn(this, this._implementation_propertyChanged));
            this.i.cellReconciling = delegateCombine(this.i.cellReconciling, runOn(this, this._implementation_cellReconciling));
        }
        this._onChanged.push(listener);
    }
    removeOnChangedListener(listener) {
        let ind = this._onChanged.indexOf(listener);
        if (ind < 0) {
            return;
        }
        this._onChanged.splice(ind, 1);
        if (this._onChanged.length == 0) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, runOn(this, this._implementation_propertyChanged));
            this.i.cellReconciling = delegateRemove(this.i.cellReconciling, runOn(this, this._implementation_cellReconciling));
        }
    }
    _implementation_propertyChanged(sender, args) {
        this._changed = true;
    }
    _implementation_cellReconciling(model) {
        if (this._changed && this._onChanged !== null && this._onChanged.length > 0) {
            this._changed = false;
            for (let i = 0; i < this._onChanged.length; i++) {
                this._onChanged[i]();
            }
        }
        this._changed = false;
    }
    get resolvedTextAlign() {
        switch (this.horizontalAlignment) {
            case CellContentHorizontalAlignment.Center:
                return "center";
            case CellContentHorizontalAlignment.Left:
                return "left";
            case CellContentHorizontalAlignment.Right:
                return "right";
            case CellContentHorizontalAlignment.Stretch:
                return "center";
        }
        return "left";
    }
    get resolvedContentOpacity() {
        let virtualPercent = Math.min(1.0, Math.max(0.0, this.virtualizationPercentage));
        let opacity = this.contentOpacity * (1.0 - virtualPercent);
        return opacity;
    }
    /**
 * Gets the style key of the current cell, used for recycling.
*/
    get styleKey() {
        return this.i.i0;
    }
    set styleKey(v) {
        this.i.i0 = v;
    }
    /**
     * Gets the absolute data row for the current cell.
    */
    get dataRow() {
        return this.i.ej;
    }
    set dataRow(v) {
        this.i.ej = +v;
    }
    /**
     * Gets if the position of the cell is dirty.
    */
    get isPositionDirty() {
        return this.i.a5;
    }
    set isPositionDirty(v) {
        this.i.a5 = ensureBool(v);
    }
    /**
     * Gets if the size of the cell is dirty.
    */
    get isSizeDirty() {
        return this.i.ba;
    }
    set isSizeDirty(v) {
        this.i.ba = ensureBool(v);
    }
    /**
     * Gets if the content of the cell is dirty.
    */
    get isContentDirty() {
        return this.i.as;
    }
    set isContentDirty(v) {
        this.i.as = ensureBool(v);
    }
    /**
     * Gets if the content of the cell is dirty.
    */
    get isBorderDirty() {
        return this.i.aq;
    }
    set isBorderDirty(v) {
        this.i.aq = ensureBool(v);
    }
    /**
     * Gets if the layer of the cell is dirty.
    */
    get isLayerDirty() {
        return this.i.a3;
    }
    set isLayerDirty(v) {
        this.i.a3 = ensureBool(v);
    }
    /**
     * Gets if the layer of the cell is dirty.
    */
    get isStateDirty() {
        return this.i.bb;
    }
    set isStateDirty(v) {
        this.i.bb = ensureBool(v);
    }
    /**
     * Gets if the data of the cell is dirty.
    */
    get isDataDirty() {
        return this.i.au;
    }
    set isDataDirty(v) {
        this.i.au = ensureBool(v);
    }
    /**
     * Gets if placeholder content is needed when virtualized.
    */
    get isPlaceholdContentNeeded() {
        return this.i.a4;
    }
    set isPlaceholdContentNeeded(v) {
        this.i.a4 = ensureBool(v);
    }
    /**
     * Gets the action manager to propagate actions back to the grid.
    */
    get actionManager() {
        return this.i.c;
    }
    set actionManager(v) {
        this.i.c = v;
    }
    /**
     * Gets if this cell belongs to a row that has been marked as pinned.
    */
    get isRowPinned() {
        return this.i.a6;
    }
    set isRowPinned(v) {
        this.i.a6 = ensureBool(v);
    }
    /**
     * Gets if this cell belongs to a row that will stick to the top of the grid.
    */
    get isRowSticky() {
        return this.i.a7;
    }
    set isRowSticky(v) {
        this.i.a7 = ensureBool(v);
    }
    /**
     * Gets if this cell is the last row that can stick to the top of the grid.
    */
    get isLastStickyRow() {
        return this.i.a2;
    }
    set isLastStickyRow(v) {
        this.i.a2 = ensureBool(v);
    }
    /**
     * Gets the indent level of the cell.
    */
    get indent() {
        return this.i.e5;
    }
    set indent(v) {
        this.i.e5 = +v;
    }
    get rowItem() {
        return this.i.gp;
    }
    set rowItem(v) {
        this.i.gp = v;
    }
    /**
     * Gets the X position of the cell within the content.
    */
    get x() {
        return this.i.cc;
    }
    set x(v) {
        this.i.cc = +v;
    }
    /**
     * Gets the Y position of the cell within the content.
    */
    get y() {
        return this.i.cd;
    }
    set y(v) {
        this.i.cd = +v;
    }
    /**
     * Gets the pixel snapped X position of the cell within the content.
    */
    get snappedX() {
        return this.i.f2;
    }
    set snappedX(v) {
        this.i.f2 = +v;
    }
    /**
     * Gets the snapped Y position of the cell within the content.
    */
    get snappedY() {
        return this.i.f4;
    }
    set snappedY(v) {
        this.i.f4 = +v;
    }
    /**
     * Gets or sets the opacity for cells that have unsaved edits.
    */
    get editOpacity() {
        return this.i.b2;
    }
    set editOpacity(v) {
        this.i.b2 = +v;
    }
    /**
     * Gets or sets the opacity of the content of the cell.
    */
    get contentOpacity() {
        return this.i.b1;
    }
    set contentOpacity(v) {
        this.i.b1 = +v;
    }
    /**
     * Gets the actual content opacity of the cell.
    */
    get actualContentOpacity() {
        return this.i.bz;
    }
    set actualContentOpacity(v) {
        this.i.bz = +v;
    }
    /**
     * Gets or sets the opacity of the cell.
    */
    get opacity() {
        return this.i.b6;
    }
    set opacity(v) {
        this.i.b6 = +v;
    }
    /**
     * Gets the actual opacity of the cell.
    */
    get actualOpacity() {
        return this.i.b0;
    }
    set actualOpacity(v) {
        this.i.b0 = +v;
    }
    /**
     * Gets the height of the cell.
    */
    get height() {
        return this.i.e0;
    }
    set height(v) {
        this.i.e0 = +v;
    }
    /**
     * Gets the width of the cell.
    */
    get width() {
        return this.i.gf;
    }
    set width(v) {
        this.i.gf = +v;
    }
    /**
     * Gets if the cell is selected.
    */
    get isSelected() {
        return this.i.a9;
    }
    set isSelected(v) {
        this.i.a9 = ensureBool(v);
    }
    /**
     * Gets the amount that the cell is selected. This is a value between 0 and 1.
    */
    get selectedStatus() {
        return this.i.b8;
    }
    set selectedStatus(v) {
        this.i.b8 = +v;
    }
    /**
     * Gets the amount that the cell is activated. This is a value between 0 and 1.
    */
    get activationStatus() {
        return this.i.by;
    }
    set activationStatus(v) {
        this.i.by = +v;
    }
    /**
     * Gets the amount that the cell is hovered. This is a value between 0 and 1.
    */
    get hoverStatus() {
        return this.i.b3;
    }
    set hoverStatus(v) {
        this.i.b3 = +v;
    }
    /**
     * Gets or sets the horiztonal alignment of the cell content.
    */
    get horizontalAlignment() {
        return this.i.f;
    }
    set horizontalAlignment(v) {
        this.i.f = ensureEnum(CellContentHorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets the vertical alignment of the cell content.
    */
    get verticalAlignment() {
        return this.i.h;
    }
    set verticalAlignment(v) {
        this.i.h = ensureEnum(CellContentVerticalAlignment_$type, v);
    }
    /**
     * Gets or sets the background color of the cell.
    */
    get background() {
        return brushToString(this.i.ke);
    }
    set background(v) {
        this.i.ke = stringToBrush(v);
    }
    /**
     * Gets or sets the border color of the cell.
    */
    get border() {
        return brushToString(this.i.kf);
    }
    set border(v) {
        this.i.kf = stringToBrush(v);
    }
    /**
     * Gets the actual background color of the cell
    */
    get actualBackground() {
        return brushToString(this.i.kb);
    }
    set actualBackground(v) {
        this.i.kb = stringToBrush(v);
    }
    /**
     * Gets the actual background color of the cell
    */
    get actualBorder() {
        return brushToString(this.i.kc);
    }
    set actualBorder(v) {
        this.i.kc = stringToBrush(v);
    }
    /**
     * Gets the actual background color of the cell
    */
    get activationBorder() {
        return brushToString(this.i.ka);
    }
    set activationBorder(v) {
        this.i.ka = stringToBrush(v);
    }
    /**
     * Gets or sets the error border color of the cell.
    */
    get errorBorder() {
        return brushToString(this.i.kh);
    }
    set errorBorder(v) {
        this.i.kh = stringToBrush(v);
    }
    /**
     * Gets or sets the selected background color of the cell.
    */
    get selectedBackground() {
        return brushToString(this.i.km);
    }
    set selectedBackground(v) {
        this.i.km = stringToBrush(v);
    }
    /**
     * Gets or sets the hover background color of the cell.
    */
    get hoverBackground() {
        return brushToString(this.i.kj);
    }
    set hoverBackground(v) {
        this.i.kj = stringToBrush(v);
    }
    /**
     * Gets or sets the color for the sort indicator icon.
    */
    get sortIndicatorColor() {
        return brushToString(this.i.kn);
    }
    set sortIndicatorColor(v) {
        this.i.kn = stringToBrush(v);
    }
    /**
     * Gets or sets the background color for the cell when it is stuck to the top of the grid as a pinned row.
    */
    get stickyRowBackground() {
        return brushToString(this.i.ko);
    }
    set stickyRowBackground(v) {
        this.i.ko = stringToBrush(v);
    }
    /**
     * Gets or sets the background color for the cell that has been marked as pinned.
    */
    get pinnedRowBackground() {
        return brushToString(this.i.kl);
    }
    set pinnedRowBackground(v) {
        this.i.kl = stringToBrush(v);
    }
    /**
     * Gets or sets the color for the last row in the sticky row area.
    */
    get lastStickyRowBackground() {
        return brushToString(this.i.kk);
    }
    set lastStickyRowBackground(v) {
        this.i.kk = stringToBrush(v);
    }
    /**
     * Gets or sets the color to use for displaying text.
    */
    get pinnedRowOpacity() {
        return this.i.b7;
    }
    set pinnedRowOpacity(v) {
        this.i.b7 = +v;
    }
    /**
     * Gets or sets the original value for the cell, before processing.
    */
    get originalValue() {
        return this.i.go;
    }
    set originalValue(v) {
        this.i.go = v;
    }
    /**
     * Gets or sets the text value, if any, which was rendered by a text cell.
    */
    get renderValue() {
        return this.i.ip;
    }
    set renderValue(v) {
        this.i.ip = v;
    }
    /**
     * Gets or sets the color of the text for the cell, if any.
    */
    get textColor() {
        return brushToString(this.i.kp);
    }
    set textColor(v) {
        this.i.kp = stringToBrush(v);
    }
    /**
     * Gets the actual color of the text for the cell, if any.
    */
    get actualTextColor() {
        return brushToString(this.i.kd);
    }
    set actualTextColor(v) {
        this.i.kd = stringToBrush(v);
    }
    /**
     * Gets or sets the text color for cells in deleted rows.
    */
    get deletedTextColor() {
        return brushToString(this.i.kg);
    }
    set deletedTextColor(v) {
        this.i.kg = stringToBrush(v);
    }
    get font() {
        if (this.i.af == null) {
            return null;
        }
        return this.i.af.fontString;
    }
    set font(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.af = fi;
    }
    get actualFont() {
        if (this.i.ad == null) {
            return null;
        }
        return this.i.ad.fontString;
    }
    set actualFont(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ad = fi;
    }
    /**
     * Gets or sets the line break mode to use if text is present in the cell.
    */
    get lineBreakMode() {
        return this.i.z;
    }
    set lineBreakMode(v) {
        this.i.z = ensureEnum(TextCellLineBreakMode_$type, v);
    }
    /**
     * Gets or sets the virtualization percentage value. This is between 0 an 1, and indicates how virtual the content is at present.
    */
    get virtualizationPercentage() {
        return this.i.cb;
    }
    set virtualizationPercentage(v) {
        this.i.cb = +v;
    }
    /**
     * Gets or sets the left padding to use for the content.
    */
    get paddingLeft() {
        return this.i.fo;
    }
    set paddingLeft(v) {
        this.i.fo = +v;
    }
    /**
     * Gets or sets the top padding to use for the content.
    */
    get paddingTop() {
        return this.i.fs;
    }
    set paddingTop(v) {
        this.i.fs = +v;
    }
    /**
     * Gets or sets the right padding to use for the content.
    */
    get paddingRight() {
        return this.i.fq;
    }
    set paddingRight(v) {
        this.i.fq = +v;
    }
    /**
     * Gets or sets the bottom padding to use for the content.
    */
    get paddingBottom() {
        return this.i.fm;
    }
    set paddingBottom(v) {
        this.i.fm = +v;
    }
    /**
     * Gets or sets the left padding to use for the content.
    */
    get actualPaddingLeft() {
        return this.i.d1;
    }
    set actualPaddingLeft(v) {
        this.i.d1 = +v;
    }
    /**
     * Gets or sets the top padding to use for the content.
    */
    get actualPaddingTop() {
        return this.i.d5;
    }
    set actualPaddingTop(v) {
        this.i.d5 = +v;
    }
    /**
     * Gets or sets the right padding to use for the content.
    */
    get actualPaddingRight() {
        return this.i.d3;
    }
    set actualPaddingRight(v) {
        this.i.d3 = +v;
    }
    /**
     * Gets or sets the bottom padding to use for the content.
    */
    get actualPaddingBottom() {
        return this.i.dz;
    }
    set actualPaddingBottom(v) {
        this.i.dz = +v;
    }
    /**
     * Gets or sets the left border to use for the content.
    */
    get borderLeftWidth() {
        return this.i.eb;
    }
    set borderLeftWidth(v) {
        this.i.eb = +v;
    }
    /**
     * Gets or sets the top border to use for the content.
    */
    get borderTopWidth() {
        return this.i.eg;
    }
    set borderTopWidth(v) {
        this.i.eg = +v;
    }
    /**
     * Gets or sets the right border to use for the content.
    */
    get borderRightWidth() {
        return this.i.ee;
    }
    set borderRightWidth(v) {
        this.i.ee = +v;
    }
    /**
     * Gets or sets the bottom border to use for the content.
    */
    get borderBottomWidth() {
        return this.i.d9;
    }
    set borderBottomWidth(v) {
        this.i.d9 = +v;
    }
    /**
     * Gets or sets the left activation border to use for the content.
    */
    get activationBorderLeftWidth() {
        return this.i.dd;
    }
    set activationBorderLeftWidth(v) {
        this.i.dd = +v;
    }
    /**
     * Gets or sets the top activation border to use for the content.
    */
    get activationBorderTopWidth() {
        return this.i.di;
    }
    set activationBorderTopWidth(v) {
        this.i.di = +v;
    }
    /**
     * Gets or sets the right activation border to use for the content.
    */
    get activationBorderRightWidth() {
        return this.i.dg;
    }
    set activationBorderRightWidth(v) {
        this.i.dg = +v;
    }
    /**
     * Gets or sets the bottom activation border to use for the content.
    */
    get activationBorderBottomWidth() {
        return this.i.db;
    }
    set activationBorderBottomWidth(v) {
        this.i.db = +v;
    }
    /**
     * Gets or sets the left error border to use for the content.
    */
    get errorBorderLeftWidth() {
        return this.i.er;
    }
    set errorBorderLeftWidth(v) {
        this.i.er = +v;
    }
    /**
     * Gets or sets the top error border to use for the content.
    */
    get errorBorderTopWidth() {
        return this.i.ew;
    }
    set errorBorderTopWidth(v) {
        this.i.ew = +v;
    }
    /**
     * Gets or sets the right error border to use for the content.
    */
    get errorBorderRightWidth() {
        return this.i.eu;
    }
    set errorBorderRightWidth(v) {
        this.i.eu = +v;
    }
    /**
     * Gets or sets the bottom error border to use for the content.
    */
    get errorBorderBottomWidth() {
        return this.i.ep;
    }
    set errorBorderBottomWidth(v) {
        this.i.ep = +v;
    }
    /**
     * Gets or sets the actual left border to use for the content.
    */
    get actualBorderLeftWidth() {
        return this.i.dp;
    }
    set actualBorderLeftWidth(v) {
        this.i.dp = +v;
    }
    /**
     * Gets or sets the actual top border to use for the content.
    */
    get actualBorderTopWidth() {
        return this.i.du;
    }
    set actualBorderTopWidth(v) {
        this.i.du = +v;
    }
    /**
     * Gets or sets the actual right border to use for the content.
    */
    get actualBorderRightWidth() {
        return this.i.ds;
    }
    set actualBorderRightWidth(v) {
        this.i.ds = +v;
    }
    /**
     * Gets or sets the actual bottom border to use for the content.
    */
    get actualBorderBottomWidth() {
        return this.i.dm;
    }
    set actualBorderBottomWidth(v) {
        this.i.dm = +v;
    }
    /**
     * Gets the current sort direction for the column containing the cell.
    */
    get sortDirection() {
        return this.i.m;
    }
    set sortDirection(v) {
        this.i.m = ensureEnum(ColumnSortDirection_$type, v);
    }
    /**
     * Gets the expansion state of the cell.
    */
    get isExpanded() {
        return this.i.az;
    }
    set isExpanded(v) {
        this.i.az = ensureBool(v);
    }
    /**
     * Gets if the cell needs to display an expansion indicator.
    */
    get isCollapsable() {
        return this.i.ar;
    }
    set isCollapsable(v) {
        this.i.ar = ensureBool(v);
    }
    /**
     * Gets the fixed column position of this cell.
    */
    get pinned() {
        return this.i.x;
    }
    set pinned(v) {
        this.i.x = ensureEnum(PinnedPositions_$type, v);
    }
    get editFont() {
        if (this.i.ae == null) {
            return null;
        }
        return this.i.ae.fontString;
    }
    set editFont(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ae = fi;
    }
    /**
     * Gets whether the cell has been edited.
    */
    get isEdited() {
        return this.i.ay;
    }
    set isEdited(v) {
        this.i.ay = ensureBool(v);
    }
    /**
     * Gets whether the cell is part of a deleted row.
    */
    get isDeleted() {
        return this.i.av;
    }
    set isDeleted(v) {
        this.i.av = ensureBool(v);
    }
    /**
     * Gets or sets the error message for the cell.
    */
    get editError() {
        return this.i.hl;
    }
    set editError(v) {
        this.i.hl = v;
    }
    /**
     * Gets whether the cell is in edit mode.
    */
    get isInEditMode() {
        return this.i.a1;
    }
    set isInEditMode(v) {
        this.i.a1 = ensureBool(v);
    }
    get editID() {
        return this.i.en;
    }
    set editID(v) {
        this.i.en = +v;
    }
    findByName(name) {
        return null;
    }
    isCustomFieldDirty(propertyName) {
        let iv = this.i.at(propertyName);
        return (iv);
    }
    /**
     * Gets if a named property is dirty.
    
    * @param propertyId  * The property id to check.
    */
    isDirtyById(propertyId_) {
        let iv = this.i.ax(propertyId_);
        return (iv);
    }
    /**
     * Gets if a named property is dirty.
    
    * @param propertyName  * The property name to check.
    */
    isDirty(propertyName) {
        let iv = this.i.aw(propertyName);
        return (iv);
    }
    setNamedValue(valueName, value) {
        this.i.jt(valueName, value);
    }
    /**
     * Returns if there is a named value stored for the cell.
    
    * @param valueName  * The name of the value to check.
    */
    hasNamedValue(valueName) {
        let iv = this.i.ap(valueName);
        return (iv);
    }
    /**
     * Removes a named value from the cell.
    
    * @param valueName  * The name of the value to remove.
    */
    removeNamedValue(valueName) {
        this.i.jq(valueName);
    }
    /**
     * Gets a named value from the cell.
    
    * @param valueName  * The name of the value to get.
    */
    getNamedValue(valueName) {
        let iv = this.i.gm(valueName);
        return (iv);
    }
}
//# sourceMappingURL=igr-cell-info.js.map
