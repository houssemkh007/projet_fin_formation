import * as React from 'react';
import { ensureEnum, brushToString, stringToBrush, ensureBool, initializePropertiesFromCss, NamePatcher, isValidProp, toSpinal, getModifiedProps } from "igniteui-react-core";
import { FontInfo } from "igniteui-react-core";
import { ReactRenderer, PortalManager } from "igniteui-react-core";
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { MultiColumnComboBox } from './MultiColumnComboBox';
import { BaseControlTheme_$type } from "igniteui-react-core";
import { ControlDisplayDensity_$type } from "igniteui-react-core";
import { SortMode_$type } from './SortMode';
import { CornerRadius } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { IgrMultiColumnComboBoxTextChangedEventArgs } from './igr-multi-column-combo-box-text-changed-event-args';
import { IgrMultiColumnComboBoxValueChangedEventArgs } from './igr-multi-column-combo-box-value-changed-event-args';
import { IgrGotFocusEventArgs } from './igr-got-focus-event-args';
import { IgrLostFocusEventArgs } from './igr-lost-focus-event-args';
export class IgrMultiColumnComboBox extends React.Component {
    constructor(props) {
        super(props);
        this._implementation = null;
        this._reactRenderer = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._gotFocus = null;
        this._gotFocus_wrapped = null;
        this._lostFocus = null;
        this._lostFocus_wrapped = null;
        this._textChanged = null;
        this._textChanged_wrapped = null;
        this._valueChanged = null;
        this._valueChanged_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._getMainRef = this._getMainRef.bind(this);
        var multiColumnComboBox = this.i;
        multiColumnComboBox.notifySizeChanged();
        if (props) {
            this.initializeProperties();
        }
        this._initialized = true;
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this.i.notifySizeChanged();
        }
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this.i.notifySizeChanged();
        }
    }
    get width() {
        return this._width;
    }
    _getMainRef(ref) {
        this._elRef = ref;
        this.verifyReferences();
    }
    render() {
        let children = [];
        // We don't actually want to support child content. 
        //let propChildren = this.props.children;        
        //React.Children.forEach(
        //    propChildren, (ch: any) => {
        //        children.push(React.cloneElement(ch));
        //    });
        if (this._portalManager)
            this._portalManager.onRender(children);
        let div = React.createElement("div", {
            ref: this._getMainRef,
            className: "ig-multi-column-combo-box igr-multi-column-combo-box",
            children: children
        });
        return div;
    }
    verifyReferences() {
        if (this._elRef) {
            this.requestRender = this.requestRender.bind(this);
            this._portalManager = new PortalManager("popupContent", this.requestRender);
            this._reactRenderer = new ReactRenderer(this._elRef, document, true, {}, this._portalManager);
            if (document) {
                this._elRef.style.display = "block";
                this._elRef.style.width = "100%";
                this._elRef.style.height = "100%";
            }
            // render needs to fire again after the portalManager is created. 
            this.requestRender();
            this.i.provideRenderer(this._reactRenderer);
            this._reactRenderer.addSizeWatcher(() => {
                this.i.notifySizeChanged();
            });
        }
    }
    requestRender() {
        if (this._initialized)
            this.setState({});
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    initializeProperties() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    // supports angular themes or custom properties set in CSS
    updateStyle() {
        this._styling(this._elRef, this);
    }
    componentWillUnmount() {
        this.i.destroy();
        if (this._reactRenderer)
            this._reactRenderer.destroy();
    }
    componentDidMount() {
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this.i.notifySizeChanged();
        this.initializeContent();
    }
    initializeContent() {
        this._styling(this._elRef, this);
        this.updateStyle();
        this.i.notifySizeChanged();
    }
    createImplementation() {
        return new MultiColumnComboBox();
    }
    get i() {
        return this._implementation;
    }
    /**
 * Gets or sets the ShowClearButton property to detirmine if the clear button is shown
*/
    get showClearButton() {
        return this.i.a9;
    }
    set showClearButton(v) {
        this.i.a9 = ensureBool(v);
    }
    /**
     * Gets or sets the desired properties for the data source to load. If specified the data source may decide to constrain the properties it fetches to these properties and must make sure that at least those properties are loaded, rather than the default behavior for that data source.
    */
    get fields() {
        return this.i.g;
    }
    set fields(v) {
        this.i.g = v;
    }
    /**
     * Gets or sets the background color to use for the input group.
    */
    get backgroundColor() {
        return brushToString(this.i.g4);
    }
    set backgroundColor(v) {
        this.i.g4 = stringToBrush(v);
    }
    /**
     * Gets the actual opacity to use for the underline ripple element.
    */
    get actualBackgroundColor() {
        return brushToString(this.i.gt);
    }
    set actualBackgroundColor(v) {
        this.i.gt = stringToBrush(v);
    }
    /**
     * Gets or sets the base built in theme to use for the component.
    */
    get baseTheme() {
        return this.i.aa;
    }
    set baseTheme(v) {
        this.i.aa = ensureEnum(BaseControlTheme_$type, v);
    }
    /**
     * Gets the actual display baseTheme to use for the component.
    */
    get actualBaseTheme() {
        return this.i.z;
    }
    set actualBaseTheme(v) {
        this.i.z = ensureEnum(BaseControlTheme_$type, v);
    }
    /**
     * Gets or sets the color to use the border of the input group.
    */
    get borderColor() {
        return brushToString(this.i.g5);
    }
    set borderColor(v) {
        this.i.g5 = stringToBrush(v);
    }
    /**
     * Gets the actual item background color.
    */
    get actualBorderColor() {
        return brushToString(this.i.gu);
    }
    set actualBorderColor(v) {
        this.i.gu = stringToBrush(v);
    }
    /**
     * Gets or sets the border width to use for the border of the item group.
    */
    get borderWidth() {
        return this.i.b4;
    }
    set borderWidth(v) {
        this.i.b4 = +v;
    }
    /**
     * Gets the actual item border width.
    */
    get actualBorderWidth() {
        return this.i.bu;
    }
    set actualBorderWidth(v) {
        this.i.bu = +v;
    }
    /**
     * Gets or sets the visibility of the drop down button.
    */
    get columnHeadersVisible() {
        return this.i.columnHeadersVisible;
    }
    set columnHeadersVisible(v) {
        this.i.columnHeadersVisible = ensureBool(v);
    }
    get contentPaddingBottom() {
        return this.i.ht ? this.i.ht.b : NaN;
    }
    set contentPaddingBottom(v) {
        this.ensureContentPadding();
        this.i.ht.b = +v;
        this.i.ht = this.i.ht;
    }
    get contentPaddingLeft() {
        return this.i.ht ? this.i.ht.c : NaN;
    }
    set contentPaddingLeft(v) {
        this.ensureContentPadding();
        this.i.ht.c = +v;
        this.i.ht = this.i.ht;
    }
    get contentPaddingRight() {
        return this.i.ht ? this.i.ht.d : NaN;
    }
    set contentPaddingRight(v) {
        this.ensureContentPadding();
        this.i.ht.d = +v;
        this.i.ht = this.i.ht;
    }
    get contentPaddingTop() {
        return this.i.ht ? this.i.ht.e : NaN;
    }
    set contentPaddingTop(v) {
        this.ensureContentPadding();
        this.i.ht.e = +v;
        this.i.ht = this.i.ht;
    }
    ensureContentPadding() {
        if (this.i.ht) {
            return;
        }
        this.i.ht = new Thickness(2);
    }
    get actualContentPaddingBottom() {
        return this.i.hs ? this.i.hs.b : NaN;
    }
    set actualContentPaddingBottom(v) {
        this.ensureActualContentPadding();
        this.i.hs.b = +v;
        this.i.hs = this.i.hs;
    }
    get actualContentPaddingLeft() {
        return this.i.hs ? this.i.hs.c : NaN;
    }
    set actualContentPaddingLeft(v) {
        this.ensureActualContentPadding();
        this.i.hs.c = +v;
        this.i.hs = this.i.hs;
    }
    get actualContentPaddingRight() {
        return this.i.hs ? this.i.hs.d : NaN;
    }
    set actualContentPaddingRight(v) {
        this.ensureActualContentPadding();
        this.i.hs.d = +v;
        this.i.hs = this.i.hs;
    }
    get actualContentPaddingTop() {
        return this.i.hs ? this.i.hs.e : NaN;
    }
    set actualContentPaddingTop(v) {
        this.ensureActualContentPadding();
        this.i.hs.e = +v;
        this.i.hs = this.i.hs;
    }
    ensureActualContentPadding() {
        if (this.i.hs) {
            return;
        }
        this.i.hs = new Thickness(2);
    }
    get cornerRadiusBottomRight() {
        return this.i.f5 ? this.i.f5.b : NaN;
    }
    set cornerRadiusBottomRight(v) {
        this.ensureCornerRadius();
        this.i.f5.b = +v;
        this.i.f5 = this.i.f5;
    }
    get cornerRadiusBottomLeft() {
        return this.i.f5 ? this.i.f5.a : NaN;
    }
    set cornerRadiusBottomLeft(v) {
        this.ensureCornerRadius();
        this.i.f5.a = +v;
        this.i.f5 = this.i.f5;
    }
    get cornerRadiusTopLeft() {
        return this.i.f5 ? this.i.f5.c : NaN;
    }
    set cornerRadiusTopLeft(v) {
        this.ensureCornerRadius();
        this.i.f5.c = +v;
        this.i.f5 = this.i.f5;
    }
    get cornerRadiusTopRight() {
        return this.i.f5 ? this.i.f5.d : NaN;
    }
    set cornerRadiusTopRight(v) {
        this.ensureCornerRadius();
        this.i.f5.d = +v;
        this.i.f5 = this.i.f5;
    }
    ensureCornerRadius() {
        if (this.i.f5) {
            return;
        }
        this.i.f5 = new CornerRadius(2);
    }
    get actualCornerRadiusBottomRight() {
        return this.i.f4 ? this.i.f4.b : NaN;
    }
    set actualCornerRadiusBottomRight(v) {
        this.ensureActualCornerRadius();
        this.i.f4.b = +v;
        this.i.f4 = this.i.f4;
    }
    get actualCornerRadiusBottomLeft() {
        return this.i.f4 ? this.i.f4.a : NaN;
    }
    set actualCornerRadiusBottomLeft(v) {
        this.ensureActualCornerRadius();
        this.i.f4.a = +v;
        this.i.f4 = this.i.f4;
    }
    get actualCornerRadiusTopLeft() {
        return this.i.f4 ? this.i.f4.c : NaN;
    }
    set actualCornerRadiusTopLeft(v) {
        this.ensureActualCornerRadius();
        this.i.f4.c = +v;
        this.i.f4 = this.i.f4;
    }
    get actualCornerRadiusTopRight() {
        return this.i.f4 ? this.i.f4.d : NaN;
    }
    set actualCornerRadiusTopRight(v) {
        this.ensureActualCornerRadius();
        this.i.f4.d = +v;
        this.i.f4 = this.i.f4;
    }
    ensureActualCornerRadius() {
        if (this.i.f4) {
            return;
        }
        this.i.f4 = new CornerRadius(2);
    }
    /**
     * Gets or sets the desired properties for the data source to load. If specified the data source may decide to constrain the properties it fetches to these properties and must make sure that at least those properties are loaded, rather than the default behavior for that data source.
    */
    get dataSourceDesiredProperties() {
        return this.i.f;
    }
    set dataSourceDesiredProperties(v) {
        this.i.f = v;
    }
    /**
     * Gets or sets the display Density to use for the buttons and dropdown grid.
    */
    get density() {
        return this.i.density;
    }
    set density(v) {
        this.i.density = ensureEnum(ControlDisplayDensity_$type, v);
    }
    /**
     * Gets the actual display Density to use for the component.
    */
    get actualDensity() {
        return this.i.ae;
    }
    set actualDensity(v) {
        this.i.ae = ensureEnum(ControlDisplayDensity_$type, v);
    }
    /**
     * Gets or sets the visibility of the drop down button.
    */
    get dropDownButtonVisible() {
        return this.i.dropDownButtonVisible;
    }
    set dropDownButtonVisible(v) {
        this.i.dropDownButtonVisible = ensureBool(v);
    }
    /**
     * Gets or sets the color to use the hovered background of the inputs in the group.
    */
    get focusBorderColor() {
        return brushToString(this.i.hh);
    }
    set focusBorderColor(v) {
        this.i.hh = stringToBrush(v);
    }
    /**
     * Gets the actual item border color.
    */
    get actualFocusBorderColor() {
        return brushToString(this.i.gv);
    }
    set actualFocusBorderColor(v) {
        this.i.gv = stringToBrush(v);
    }
    /**
     * Gets or sets the border width to use for the border of the item group when focused.
    */
    get focusBorderWidth() {
        return this.i.cg;
    }
    set focusBorderWidth(v) {
        this.i.cg = +v;
    }
    /**
     * Gets the actual item border width.
    */
    get actualFocusBorderWidth() {
        return this.i.bv;
    }
    set actualFocusBorderWidth(v) {
        this.i.bv = +v;
    }
    /**
     * Gets or sets the color to use for the underline element.
    */
    get focusUnderlineColor() {
        return brushToString(this.i.hi);
    }
    set focusUnderlineColor(v) {
        this.i.hi = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the underline element when focused.
    */
    get actualFocusUnderlineColor() {
        return brushToString(this.i.gw);
    }
    set actualFocusUnderlineColor(v) {
        this.i.gw = stringToBrush(v);
    }
    /**
     * Gets or sets the color to use for the underline element.
    */
    get focusUnderlineOpacity() {
        return this.i.ch;
    }
    set focusUnderlineOpacity(v) {
        this.i.ch = +v;
    }
    /**
     * Gets the actual opacity to use for the underline element when focused.
    */
    get actualFocusUnderlineOpacity() {
        return this.i.bw;
    }
    set actualFocusUnderlineOpacity(v) {
        this.i.bw = +v;
    }
    /**
     * Gets or sets the opacity to use for the underline ripple element when focused.
    */
    get focusUnderlineRippleOpacity() {
        return this.i.ci;
    }
    set focusUnderlineRippleOpacity(v) {
        this.i.ci = +v;
    }
    /**
     * Gets the actual opacity to use for the underline ripple element when focused.
    */
    get actualFocusUnderlineRippleOpacity() {
        return this.i.bx;
    }
    set actualFocusUnderlineRippleOpacity(v) {
        this.i.bx = +v;
    }
    /**
     * Gets or sets the color to use for the underline element.
    */
    get hoverUnderlineColor() {
        return brushToString(this.i.hj);
    }
    set hoverUnderlineColor(v) {
        this.i.hj = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the underline element.
    */
    get actualHoverUnderlineColor() {
        return brushToString(this.i.gx);
    }
    set actualHoverUnderlineColor(v) {
        this.i.gx = stringToBrush(v);
    }
    /**
     * Gets or sets the color to use for the underline element.
    */
    get hoverUnderlineOpacity() {
        return this.i.cj;
    }
    set hoverUnderlineOpacity(v) {
        this.i.cj = +v;
    }
    /**
     * Gets the actual opacity to use for the underline element when hovered.
    */
    get actualHoverUnderlineOpacity() {
        return this.i.by;
    }
    set actualHoverUnderlineOpacity(v) {
        this.i.by = +v;
    }
    /**
     * Gets or sets the width to use for the underline element when hovered.
    */
    get hoverUnderlineWidth() {
        return this.i.ck;
    }
    set hoverUnderlineWidth(v) {
        this.i.ck = +v;
    }
    /**
     * Gets the width to use for the underline element when hovered.
    */
    get actualHoverUnderlineWidth() {
        return this.i.bz;
    }
    set actualHoverUnderlineWidth(v) {
        this.i.bz = +v;
    }
    /**
     * Gets or sets the data to which to bind the combo box list. This can be some type of array or list, or it can
     * be an IDataSource instance.
    */
    get dataSource() {
        return this.i.itemsSource;
    }
    set dataSource(v) {
        this.i.itemsSource = v;
    }
    /**
     * Gets the actual data source that is being used by the combo box list. If a collection was provided for the combo box data, an implicit LocalDataSource has been created, and this is available via this property.
    */
    get actualDataSource() {
        return this.i.actualDataSource;
    }
    /**
     * The text displayed in the label portion of the control.
    */
    get label() {
        return this.i.eo;
    }
    set label(v) {
        this.i.eo = v;
    }
    /**
     * Gets or sets the color to use for the text.
    */
    get labelTextColor() {
        return brushToString(this.i.hk);
    }
    set labelTextColor(v) {
        this.i.hk = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the text color.
    */
    get actualLabelTextColor() {
        return brushToString(this.i.gy);
    }
    set actualLabelTextColor(v) {
        this.i.gy = stringToBrush(v);
    }
    /**
     * Gets or sets the font to use for the combobox.
    */
    get labelTextStyle() {
        if (this.i.au == null) {
            return null;
        }
        return this.i.au.fontString;
    }
    set labelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.au = fi;
    }
    /**
     * Gets or sets the visibility of the label.
    */
    get actualLabelVisible() {
        return this.i.actualLabelVisible;
    }
    set actualLabelVisible(v) {
        this.i.actualLabelVisible = ensureBool(v);
    }
    /**
     * Gets or sets the text to display on the list when no suggested matches are found.
    */
    get noMatchesFoundLabel() {
        return this.i.eu;
    }
    set noMatchesFoundLabel(v) {
        this.i.eu = v;
    }
    /**
     * Gets the actual text to display on the list when no suggested matches are found.
    */
    get actualNoMatchesFoundLabel() {
        return this.i.actualNoMatchesFoundLabel;
    }
    set actualNoMatchesFoundLabel(v) {
        this.i.actualNoMatchesFoundLabel = v;
    }
    /**
     * Gets or sets the color to use for the "no matches found" label.
    */
    get noMatchesFoundLabelBackgroundColor() {
        return brushToString(this.i.hl);
    }
    set noMatchesFoundLabelBackgroundColor(v) {
        this.i.hl = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the "no matches found" label.
    */
    get actualNoMatchesFoundLabelBackgroundColor() {
        return brushToString(this.i.gz);
    }
    set actualNoMatchesFoundLabelBackgroundColor(v) {
        this.i.gz = stringToBrush(v);
    }
    /**
     * Gets or sets the color to use for the "no matches found" label.
    */
    get noMatchesFoundLabelTextColor() {
        return brushToString(this.i.hm);
    }
    set noMatchesFoundLabelTextColor(v) {
        this.i.hm = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the "no matches found" label.
    */
    get actualNoMatchesFoundLabelTextColor() {
        return brushToString(this.i.g0);
    }
    set actualNoMatchesFoundLabelTextColor(v) {
        this.i.g0 = stringToBrush(v);
    }
    /**
     * Gets or sets the font to use for the combobox.
    */
    get noMatchesFoundLabelTextStyle() {
        if (this.i.av == null) {
            return null;
        }
        return this.i.av.fontString;
    }
    set noMatchesFoundLabelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.av = fi;
    }
    /**
     * Placeholder text which gives the user a hint about what kind of text is expected.
    */
    get placeholder() {
        return this.i.ez;
    }
    set placeholder(v) {
        this.i.ez = v;
    }
    /**
     * Gets or sets the visibility of the row separators in the drop down.
    */
    get rowSeparatorsVisible() {
        return this.i.rowSeparatorsVisible;
    }
    set rowSeparatorsVisible(v) {
        this.i.rowSeparatorsVisible = ensureBool(v);
    }
    /**
     * Gets or sets the color to use for the text.
    */
    get textColor() {
        return brushToString(this.i.hn);
    }
    set textColor(v) {
        this.i.hn = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the text color.
    */
    get actualTextColor() {
        return brushToString(this.i.g1);
    }
    set actualTextColor(v) {
        this.i.g1 = stringToBrush(v);
    }
    /**
     * Gets or sets the font to use for the combobox.
    */
    get textStyle() {
        if (this.i.aw == null) {
            return null;
        }
        return this.i.aw.fontString;
    }
    set textStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.aw = fi;
    }
    /**
     * Gets or sets the color to use for the underline element.
    */
    get underlineColor() {
        return brushToString(this.i.ho);
    }
    set underlineColor(v) {
        this.i.ho = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the underline element.
    */
    get actualUnderlineColor() {
        return brushToString(this.i.g2);
    }
    set actualUnderlineColor(v) {
        this.i.g2 = stringToBrush(v);
    }
    /**
     * Gets or sets the color to use for the underline element.
    */
    get underlineOpacity() {
        return this.i.cl;
    }
    set underlineOpacity(v) {
        this.i.cl = +v;
    }
    /**
     * Gets the actual opacity to use for the underline element.
    */
    get actualUnderlineOpacity() {
        return this.i.b0;
    }
    set actualUnderlineOpacity(v) {
        this.i.b0 = +v;
    }
    /**
     * Gets or sets the color to use for the underline ripple element.
    */
    get underlineRippleColor() {
        return brushToString(this.i.hp);
    }
    set underlineRippleColor(v) {
        this.i.hp = stringToBrush(v);
    }
    /**
     * Gets the actual color to use for the underline ripple element.
    */
    get actualUnderlineRippleColor() {
        return brushToString(this.i.g3);
    }
    set actualUnderlineRippleColor(v) {
        this.i.g3 = stringToBrush(v);
    }
    /**
     * Gets or sets the opacity to use for the underline ripple element.
    */
    get underlineRippleOpacity() {
        return this.i.cm;
    }
    set underlineRippleOpacity(v) {
        this.i.cm = +v;
    }
    /**
     * Gets the actual opacity to use for the underline ripple element.
    */
    get actualUnderlineRippleOpacity() {
        return this.i.b1;
    }
    set actualUnderlineRippleOpacity(v) {
        this.i.b1 = +v;
    }
    /**
     * Gets or sets the width to use for the underline element.
    */
    get underlineRippleWidth() {
        return this.i.cn;
    }
    set underlineRippleWidth(v) {
        this.i.cn = +v;
    }
    /**
     * Gets the actual width to use for the underline element.
    */
    get actualUnderlineRippleWidth() {
        return this.i.b2;
    }
    set actualUnderlineRippleWidth(v) {
        this.i.b2 = +v;
    }
    /**
     * Gets or sets the width to use for the underline element.
    */
    get underlineWidth() {
        return this.i.co;
    }
    set underlineWidth(v) {
        this.i.co = +v;
    }
    /**
     * Gets the actual width to use for the underline element.
    */
    get actualUnderlineWidth() {
        return this.i.b3;
    }
    set actualUnderlineWidth(v) {
        this.i.b3 = +v;
    }
    /**
     * Whether to allow filtering of the combo
    */
    get allowFilter() {
        return this.i.a2;
    }
    set allowFilter(v) {
        this.i.a2 = ensureBool(v);
    }
    /**
     * Returns/sets the action to take when a column header is clicked.
    */
    get sortMode() {
        return this.i.v;
    }
    set sortMode(v) {
        this.i.v = ensureEnum(SortMode_$type, v);
    }
    /**
     * Determines the name of the field in the data source will be used as the Text of the MultiColumnComboBox.
    */
    get textField() {
        return this.i.e7;
    }
    set textField(v) {
        this.i.e7 = v;
    }
    /**
     * The text displayed in the edit portion of the control.
    */
    get text() {
        return this.i.e5;
    }
    set text(v) {
        this.i.e5 = v;
    }
    /**
     * Sets or gets the user provided primary key to assume for the data. Certain functionality of the combo (such as the the current Value) requires
     * a way to uniquely identify items in order to work correctly.
     * If a primary key cannot be inferred from the data source, you may need to provide one here.
    */
    get valueField() {
        return this.i.j;
    }
    set valueField(v) {
        this.i.j = v;
    }
    /**
     * Gets the actual name of the field in the data source will be used as the Value of the MultiColumnComboBox.
    */
    get actualValueField() {
        return this.i.e;
    }
    set actualValueField(v) {
        this.i.e = v;
    }
    /**
     * Gets or sets the Value of the combo.
     * When the user selects an item from, the value is set based on the specified ValueField field. If not ValueField is specified, then the first field in the data source is used.
     * When the user enters text into the combo, the list is searched based on the TextField field. If a matching string is found, the Value of the combo is the value of the ValueField field in the same row.
     * If the text entered in the combo does not match any item on the list, then the value will return null.
    */
    get value() {
        return this.i.cv;
    }
    set value(v) {
        this.i.cv = v;
    }
    findByName(name) {
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("MultiColumnComboBox");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Programmatically closes the list.

*/
    closeUp() {
        this.i.closeUp();
    }
    /**
     * Programmatically drops down the list.
    
    */
    dropDown() {
        this.i.dropDown();
    }
    /**
     * Programmatically focus the combo input area.
    
    */
    focus() {
        this.i.focus();
    }
    /**
     * Selects all the text in the combo input area.
    
    */
    select() {
        this.i.select();
    }
    /**
     * Exports visual information about the current state of the grid.
    
    */
    exportVisualModel() {
        let iv = this.i.cr();
        return (iv);
    }
    /**
     * Returns a serialized copy of the exported visual model
    
    */
    exportSerializedVisualModel() {
        let iv = this.i.ea();
        return (iv);
    }
    get gotFocus() {
        return this._gotFocus;
    }
    set gotFocus(ev) {
        if (this._gotFocus_wrapped !== null) {
            this.i.gotFocus = delegateRemove(this.i.gotFocus, this._gotFocus_wrapped);
            this._gotFocus_wrapped = null;
            this._gotFocus = null;
        }
        this._gotFocus = ev;
        this._gotFocus_wrapped = (o, e) => {
            let outerArgs = new IgrGotFocusEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeGotFocus) {
                this.beforeGotFocus(this, outerArgs);
            }
            if (this._gotFocus) {
                this._gotFocus(this, outerArgs);
            }
        };
        this.i.gotFocus = delegateCombine(this.i.gotFocus, this._gotFocus_wrapped);
    }
    get lostFocus() {
        return this._lostFocus;
    }
    set lostFocus(ev) {
        if (this._lostFocus_wrapped !== null) {
            this.i.lostFocus = delegateRemove(this.i.lostFocus, this._lostFocus_wrapped);
            this._lostFocus_wrapped = null;
            this._lostFocus = null;
        }
        this._lostFocus = ev;
        this._lostFocus_wrapped = (o, e) => {
            let outerArgs = new IgrLostFocusEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeLostFocus) {
                this.beforeLostFocus(this, outerArgs);
            }
            if (this._lostFocus) {
                this._lostFocus(this, outerArgs);
            }
        };
        this.i.lostFocus = delegateCombine(this.i.lostFocus, this._lostFocus_wrapped);
    }
    get textChanged() {
        return this._textChanged;
    }
    set textChanged(ev) {
        if (this._textChanged_wrapped !== null) {
            this.i.textChanged = delegateRemove(this.i.textChanged, this._textChanged_wrapped);
            this._textChanged_wrapped = null;
            this._textChanged = null;
        }
        this._textChanged = ev;
        this._textChanged_wrapped = (o, e) => {
            let outerArgs = new IgrMultiColumnComboBoxTextChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeTextChanged) {
                this.beforeTextChanged(this, outerArgs);
            }
            if (this._textChanged) {
                this._textChanged(this, outerArgs);
            }
        };
        this.i.textChanged = delegateCombine(this.i.textChanged, this._textChanged_wrapped);
    }
    get valueChanged() {
        return this._valueChanged;
    }
    set valueChanged(ev) {
        if (this._valueChanged_wrapped !== null) {
            this.i.valueChanged = delegateRemove(this.i.valueChanged, this._valueChanged_wrapped);
            this._valueChanged_wrapped = null;
            this._valueChanged = null;
        }
        this._valueChanged = ev;
        this._valueChanged_wrapped = (o, e) => {
            let outerArgs = new IgrMultiColumnComboBoxValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeValueChanged) {
                this.beforeValueChanged(this, outerArgs);
            }
            if (this._valueChanged) {
                this._valueChanged(this, outerArgs);
            }
        };
        this.i.valueChanged = delegateCombine(this.i.valueChanged, this._valueChanged_wrapped);
    }
}
//# sourceMappingURL=igr-multi-column-combo-box.js.map
