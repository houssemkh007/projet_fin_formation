import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { IgrGridColumnAnimationSettings } from "./igr-grid-column-animation-settings";
import { IgrColumnWidth } from "./igr-column-width";
import { IgrHeader } from "./igr-header";
import { ColumnSortDirection_$type } from "./ColumnSortDirection";
import { PinnedPositions_$type } from "./PinnedPositions";
import { ColumnOptionsIconAlignment_$type } from "./ColumnOptionsIconAlignment";
import { ColumnOptionsIconBehavior_$type } from "./ColumnOptionsIconBehavior";
import { IgrDefinitionBase } from "./igr-definition-base";
import { brushToString, stringToBrush, ensureBool, ensureEnum } from "igniteui-react-core";
import { ColumnWidth as ColumnWidth_internal } from "./ColumnWidth";
import { FontInfo } from "igniteui-react-core";
/**
 * A column in the data grid.
*/
export class IgrColumn extends IgrDefinitionBase {
    constructor(props) {
        super(props);
        this._actualHeaderTextChange = null;
        this._actualHeaderTextChange_wrapped = null;
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the amount of left padding to use for the cell content for this column.
    */
    get paddingLeft() {
        return this.i.gy;
    }
    set paddingLeft(v) {
        this.i.gy = +v;
    }
    /**
     * Gets or sets the amount of top padding to use for the cell content for this column.
    */
    get paddingTop() {
        return this.i.g0;
    }
    set paddingTop(v) {
        this.i.g0 = +v;
    }
    /**
     * Gets or sets the amount of right padding to use for the cell content of this column.
    */
    get paddingRight() {
        return this.i.gz;
    }
    set paddingRight(v) {
        this.i.gz = +v;
    }
    /**
     * Gets or sets the amount of bottom padding to use for the cell content of this column.
    */
    get paddingBottom() {
        return this.i.gx;
    }
    set paddingBottom(v) {
        this.i.gx = +v;
    }
    /**
     * Gets or sets an unique name of the Column
    */
    get name() {
        return this.i.id;
    }
    set name(v) {
        this.i.id = v;
    }
    /**
     * Gets or sets the key used for the column binding
    */
    get field() {
        return this.i.hy;
    }
    set field(v) {
        this.i.hy = v;
    }
    /**
     * Gets or sets the text displayed in the header of the column
    */
    get headerText() {
        return this.i.h2;
    }
    set headerText(v) {
        this.i.h2 = v;
    }
    /**
     * Gets the actual text displayed in the header of the column
    */
    get actualHeaderText() {
        return this.i.hh;
    }
    set actualHeaderText(v) {
        this.i.hh = v;
    }
    /**
     * Gets or sets the background color to use for the cells when they are selected
    */
    get selectedBackground() {
        return brushToString(this.i.jn);
    }
    set selectedBackground(v) {
        this.i.jn = stringToBrush(v);
    }
    /**
     * Gets the actual background color that is used for the cells when they are selected
    */
    get actualSelectedBackground() {
        return brushToString(this.i.jh);
    }
    set actualSelectedBackground(v) {
        this.i.jh = stringToBrush(v);
    }
    /**
     * Gets or sets the background color to use for the cells when the row is hovered.
    */
    get rowHoverBackground() {
        return brushToString(this.i.jm);
    }
    set rowHoverBackground(v) {
        this.i.jm = stringToBrush(v);
    }
    /**
     * Gets the actual background color that is used for the cells when they are hovered.
    */
    get actualHoverBackground() {
        return brushToString(this.i.jg);
    }
    set actualHoverBackground(v) {
        this.i.jg = stringToBrush(v);
    }
    /**
     * Gets or sets the animation settings to use for this column.
    */
    get animationSettings() {
        if (this.i.fe == null) {
            return null;
        }
        if (!this.i.fe.externalObject) {
            let e = new IgrGridColumnAnimationSettings();
            e._implementation = this.i.fe;
            this.i.fe.externalObject = e;
        }
        return this.i.fe.externalObject;
    }
    set animationSettings(v) {
        v == null ? this.i.fe = null : this.i.fe = v.i;
    }
    /**
     * Gets or sets the width to use for this column.
    */
    get width() {
        if (this.i.width == null) {
            return null;
        }
        if (!this.i.width.externalObject) {
            let e = new IgrColumnWidth();
            e._implementation = this.i.width;
            this.i.width.externalObject = e;
        }
        return this.i.width.externalObject;
    }
    set width(v) {
        if (typeof v == "string") {
            let int = ColumnWidth_internal.parse(v);
            let ext = new IgrColumnWidth();
            ext._implementation = int;
            v = ext;
        }
        v == null ? this.i.width = null : this.i.width = v.i;
    }
    /**
     * Gets or sets the minimum width to use for this column. Overrides the DefaultColumnMinWidth from the grid, if set.
    */
    get minWidth() {
        return this.i.gm;
    }
    set minWidth(v) {
        this.i.gm = +v;
    }
    /**
     * Gets whether this column was projected from markup/templates and is constrained.
    */
    get isFromMarkup() {
        return this.i.gc;
    }
    set isFromMarkup(v) {
        this.i.gc = ensureBool(v);
    }
    /**
     * Gets whether this column was auto generated.
    */
    get isAutoGenerated() {
        return this.i.f8;
    }
    set isAutoGenerated(v) {
        this.i.f8 = ensureBool(v);
    }
    /**
     * Gets or sets a filter to apply on the values of this column
    */
    get filter() {
        return this.i.eo;
    }
    set filter(v) {
        this.i.eo = v;
    }
    /**
     * Gets or sets the header definition for this column.
    */
    get header() {
        if (this.i.header == null) {
            return null;
        }
        if (!this.i.header.externalObject) {
            let e = IgrHeader._createFromInternal(this.i.header);
            if (e) {
                e._implementation = this.i.header;
            }
            this.i.header.externalObject = e;
        }
        return this.i.header.externalObject;
    }
    set header(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.header = null : this.i.header = v.i;
    }
    /**
     * Gets or sets whether filtering is enabled for this column.
    */
    get isFilteringEnabled() {
        return this.i.gb;
    }
    set isFilteringEnabled(v) {
        this.i.gb = ensureBool(v);
    }
    /**
     * Gets or sets whether resizing is enabled for this column.
    */
    get isResizingEnabled() {
        return this.i.ge;
    }
    set isResizingEnabled(v) {
        this.i.ge = ensureBool(v);
    }
    /**
     * Gets or sets whether or not a column is hidden from the grid
    */
    get isHidden() {
        return this.i.gd;
    }
    set isHidden(v) {
        this.i.gd = ensureBool(v);
    }
    /**
     * Gets or sets if a column should be removed from the grid when it is fully hidden
    */
    get shouldRemoveWhenHidden() {
        return this.i.gg;
    }
    set shouldRemoveWhenHidden(v) {
        this.i.gg = ensureBool(v);
    }
    /**
     * Gets the current sort direction (None, Ascending, Descending) for this column.
    */
    get sortDirection() {
        return this.i.e6;
    }
    set sortDirection(v) {
        this.i.e6 = ensureEnum(ColumnSortDirection_$type, v);
    }
    /**
     * Gets or sets the current fixed position for this column.
    */
    get pinned() {
        return this.i.fk;
    }
    set pinned(v) {
        this.i.fk = ensureEnum(PinnedPositions_$type, v);
    }
    /**
     * Gets the actual column options icon alignment for this column.
    */
    get actualColumnOptionsIconAlignment() {
        return this.i.ex;
    }
    set actualColumnOptionsIconAlignment(v) {
        this.i.ex = ensureEnum(ColumnOptionsIconAlignment_$type, v);
    }
    /**
     * Gets or sets whether the column options icon is aligned opposite the header text or not.
    */
    get columnOptionsIconAlignment() {
        return this.i.ey;
    }
    set columnOptionsIconAlignment(v) {
        this.i.ey = ensureEnum(ColumnOptionsIconAlignment_$type, v);
    }
    /**
     * Gets the actual column options icon color for this column.
    */
    get actualColumnOptionsIconColor() {
        return brushToString(this.i.je);
    }
    set actualColumnOptionsIconColor(v) {
        this.i.je = stringToBrush(v);
    }
    /**
     * Gets or sets the column options icon color for this column.
    */
    get columnOptionsIconColor() {
        return brushToString(this.i.ji);
    }
    set columnOptionsIconColor(v) {
        this.i.ji = stringToBrush(v);
    }
    /**
     * Gets or sets how the column option icon will behave in the column header.
    */
    get columnOptionsIconBehavior() {
        return this.i.e2;
    }
    set columnOptionsIconBehavior(v) {
        this.i.e2 = ensureEnum(ColumnOptionsIconBehavior_$type, v);
    }
    /**
     * Gets or sets how the column option icon will behave in the column header.
    */
    get actualColumnOptionsIconBehavior() {
        return this.i.e1;
    }
    set actualColumnOptionsIconBehavior(v) {
        this.i.e1 = ensureEnum(ColumnOptionsIconBehavior_$type, v);
    }
    /**
     * Gets the actual state of the column options for this column.
    */
    get actualIsColumnOptionsEnabled() {
        return this.i.f3;
    }
    set actualIsColumnOptionsEnabled(v) {
        this.i.f3 = ensureBool(v);
    }
    /**
     * Gets or sets the preferred state of the column options for this column. If the feature is disabled at the grid level
     * then it will be disabled for the column regardless of what this is set to.
    */
    get isColumnOptionsEnabled() {
        return this.i.f9;
    }
    set isColumnOptionsEnabled(v) {
        this.i.f9 = ensureBool(v);
    }
    /**
     * Gets or sets if the column is editable.
    */
    get isEditable() {
        return this.i.ga;
    }
    set isEditable(v) {
        this.i.ga = ensureBool(v);
    }
    /**
     * Gets or sets the text color used for deleted rows.
    */
    get deletedTextColor() {
        return brushToString(this.i.jj);
    }
    set deletedTextColor(v) {
        this.i.jj = stringToBrush(v);
    }
    /**
     * Gets the actual text color used for deleted rows.
    */
    get actualDeletedTextColor() {
        return brushToString(this.i.jf);
    }
    set actualDeletedTextColor(v) {
        this.i.jf = stringToBrush(v);
    }
    /**
     * Gets or sets the opacity to use for unsaved edited cell values.
    */
    get editOpacity() {
        return this.i.gl;
    }
    set editOpacity(v) {
        this.i.gl = +v;
    }
    /**
     * Gets the actual opacity for unsaved edited cell values.
    */
    get actualEditOpacity() {
        return this.i.gk;
    }
    set actualEditOpacity(v) {
        this.i.gk = +v;
    }
    /**
     * Gets or sets the font style to use for unsaved cell edits.
    */
    get textEditStyle() {
        if (this.i.textEditStyle == null) {
            return null;
        }
        return this.i.textEditStyle.fontString;
    }
    set textEditStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.textEditStyle = fi;
    }
    /**
     * Gets the actual font style used for unsaved cell edits.
    */
    get actualEditFontInfo() {
        if (this.i.fp == null) {
            return null;
        }
        return this.i.fp.fontString;
    }
    set actualEditFontInfo(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.fp = fi;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.animationSettings && this.animationSettings.name && this.animationSettings.name == name) {
            return this.animationSettings;
        }
        if (this.width && this.width.name && this.width.name == name) {
            return this.width;
        }
        if (this.header && this.header.name && this.header.name == name) {
            return this.header;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.header && this.header._styling) {
            this.header._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Get the unique key used to identify this column.
    
    */
    getUniqueKey() {
        let iv = this.i.h0();
        return (iv);
    }
    setNamedHeaderValue(valueName, animationType, value) {
        this.i.iu(valueName, (animationType == null ? null : animationType), value);
    }
    /**
     * Returns if the column has named header values.
    
    */
    hasNamedHeaderValues() {
        let iv = this.i.f6();
        return (iv);
    }
    /**
     * Returns if there is a named header value with a given name.
    
    * @param valueName  * The named value to check for.
    */
    hasNamedHeaderValue(valueName) {
        let iv = this.i.f5(valueName);
        return (iv);
    }
    /**
     * Removes a named header value with the given name from the named header values for this column.
    
    * @param valueName  * The named header value to remove.
    */
    removeNamedHeaderValue(valueName) {
        this.i.it(valueName);
    }
    /**
     * Gets the value of a named header value for this column by name.
    
    * @param valueName  * Name of the named header value to retrieve.
    */
    getNamedHeaderValue(valueName) {
        let iv = this.i.g5(valueName);
        return (iv);
    }
    get actualHeaderTextChange() {
        return this._actualHeaderTextChange;
    }
    set actualHeaderTextChange(ev) {
        if (this._actualHeaderTextChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualHeaderTextChange_wrapped);
            this._actualHeaderTextChange_wrapped = null;
            this._actualHeaderTextChange = null;
        }
        this._actualHeaderTextChange = ev;
        this._actualHeaderTextChange_wrapped = (o, e) => {
            let ext = this.actualHeaderText;
            if (this.beforeActualHeaderTextChange) {
                this.beforeActualHeaderTextChange(this, ext);
            }
            if (this._actualHeaderTextChange) {
                this._actualHeaderTextChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualHeaderTextChange_wrapped);
    }
}
//# sourceMappingURL=igr-column.js.map
